<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursion Tutorial - CPCS 204</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-align: center;
            padding: 40px 20px;
        }

        header .header-content {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        header img {
            width: 8cm;
            height: 4cm;
            object-fit: contain;
        }

        header .header-text {
            text-align: left;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .content {
            padding: 40px;
        }

        section {
            margin-bottom: 50px;
        }

        h2 {
            color: #667eea;
            font-size: 2em;
            margin-bottom: 20px;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        h3 {
            color: #764ba2;
            font-size: 1.5em;
            margin: 25px 0 15px 0;
        }

        h4 {
            color: #555;
            font-size: 1.2em;
            margin: 20px 0 10px 0;
        }

        p {
            margin-bottom: 12px;
        }

        .highlight-box {
            background: #f0f4ff;
            border-left: 5px solid #667eea;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .definition {
            background: #e8f5e9;
            border-left: 5px solid #4caf50;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
            font-size: 1.1em;
        }

        .important {
            background: #fff3cd;
            border-left: 5px solid #ffc107;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .warning {
            background: #ffebee;
            border-left: 5px solid #f44336;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .teacher-says {
            background: #f3e5f5;
            border-left: 5px solid #9c27b0;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .teacher-says::before {
            content: "Professor: ";
            font-weight: bold;
            color: #7b1fa2;
        }

        .student-says {
            background: #e3f2fd;
            border-left: 5px solid #2196f3;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .student-says::before {
            content: "Student: ";
            font-weight: bold;
            color: #1565c0;
        }

        ul, ol {
            margin-left: 30px;
            margin-top: 10px;
            margin-bottom: 10px;
        }

        li {
            margin: 8px 0;
        }

        /* Code Blocks */
        .code-container { margin: 20px 0; }
        .code-header {
            background: #667eea;
            color: white;
            padding: 14px 24px;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            font-size: 1.15em;
            transition: background 0.3s;
        }
        .code-header:hover { background: #5568d3; }
        .code-toggle { font-size: 1.2em; transition: transform 0.3s; }
        .code-toggle.collapsed { transform: rotate(-90deg); }

        .code-block {
            background: #000000;
            color: #f8f8f2;
            padding: 25px 30px;
            border-radius: 0 0 8px 8px;
            overflow-x: auto;
            font-family: 'Courier New', Consolas, 'Liberation Mono', monospace;
            font-size: 1.25em;
            line-height: 1.8;
            white-space: pre;
            max-height: 800px;
            overflow-y: auto;
            transition: max-height 0.3s ease;
            letter-spacing: 0.3px;
        }
        .code-block.collapsed { max-height: 0; padding: 0 20px; overflow: hidden; }
        .code-block .comment { color: #7a8bbf; }
        .code-block .keyword { color: #ff79c6; font-weight: bold; }
        .code-block .class-name { color: #50fa7b; font-weight: bold; }
        .code-block .method { color: #8be9fd; }
        .code-block .string { color: #f1fa8c; }
        .code-block .number { color: #bd93f9; }

        /* Stack Visualization */
        .stack-container {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            margin: 30px 0;
            gap: 40px;
            flex-wrap: wrap;
        }

        .stack-visual {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stack-box {
            width: 240px;
            border: 3px solid #667eea;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            background: #f9f9f9;
            position: relative;
            margin-top: 10px;
            gap: 4px;
        }

        .stack-box-label {
            text-align: center;
            font-weight: bold;
            color: #667eea;
            font-size: 0.9em;
            letter-spacing: 2px;
            margin-bottom: 6px;
        }

        .stack-box-empty {
            color: #aaa;
            font-style: italic;
            font-size: 0.85em;
            padding: 30px 0;
        }

        .stack-frame {
            width: 210px;
            padding: 10px 8px;
            text-align: center;
            border-radius: 6px;
            font-weight: bold;
            font-size: 0.85em;
            animation: pushFrame 0.4s ease;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .stack-frame.main-frame {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .stack-frame.method-frame {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .stack-frame.counter-frame-1 {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        .stack-frame.counter-frame-2 {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            color: white;
        }

        .stack-frame.counter-frame-3 {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            color: white;
        }

        .stack-frame.counter-frame-4 {
            background: linear-gradient(135deg, #a18cd1 0%, #fbc2eb 100%);
            color: white;
        }

        .stack-frame.counter-frame-5 {
            background: linear-gradient(135deg, #fccb90 0%, #d57eeb 100%);
            color: white;
        }

        .stack-frame.recursive-frame {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .stack-frame.overflow-frame {
            background: linear-gradient(135deg, #f44336 0%, #c62828 100%);
            color: white;
            font-size: 0.75em;
            padding: 4px 6px;
            margin: 1px 0;
        }

        @keyframes pushFrame {
            from {
                opacity: 0;
                transform: translateY(-30px) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        @keyframes popFrame {
            from {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            to {
                opacity: 0;
                transform: translateY(-30px) scale(0.8);
            }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        @keyframes explode {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); border-color: #f44336; }
            100% { transform: scale(1); opacity: 1; border-color: #f44336; }
        }

        .stack-label {
            margin-top: 10px;
            font-weight: bold;
            color: #667eea;
            font-size: 0.95em;
        }

        .stack-pointer {
            position: absolute;
            right: -60px;
            font-weight: bold;
            color: #f44336;
            font-size: 0.85em;
        }

        /* Animation Controls */
        .animation-controls {
            text-align: center;
            margin: 20px 0;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 25px;
            font-size: 1em;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin: 5px;
            font-weight: 600;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-success {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            color: #1a1a2e;
        }

        .btn-danger {
            background: linear-gradient(135deg, #f44336 0%, #c62828 100%);
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffa726 0%, #fb8c00 100%);
        }

        /* Output Console */
        .output-console {
            background: #1a1a2e;
            color: #0f0;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            margin: 15px 0;
            min-height: 50px;
            border: 2px solid #333;
        }

        .output-console .output-header {
            color: #888;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #333;
        }

        .output-line {
            margin: 4px 0;
            animation: typeLine 0.3s ease;
        }

        @keyframes typeLine {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }

        /* Narration Box */
        .narration {
            background: linear-gradient(135deg, #667eea15, #764ba215);
            border: 2px solid #667eea;
            border-radius: 12px;
            padding: 18px 24px;
            margin: 15px 0;
            text-align: center;
            font-size: 1.05em;
            color: #444;
            min-height: 60px;
            line-height: 1.7;
            word-spacing: 0.05em;
        }

        /* Comparison Table */
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .comparison-table thead {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .comparison-table th {
            padding: 15px 20px;
            text-align: center;
            font-size: 1.1em;
        }

        .comparison-table td {
            padding: 12px 20px;
            border-bottom: 1px solid #e0e0e0;
            text-align: center;
        }

        .comparison-table tbody tr:nth-child(even) {
            background: #f8f9ff;
        }

        .comparison-table tbody tr:hover {
            background: #e8ecff;
        }

        /* Approach Cards */
        .approach-cards {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .approach-card {
            flex: 1;
            min-width: 280px;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .approach-card.iterative {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            border: 2px solid #2196f3;
        }

        .approach-card.recursive {
            background: linear-gradient(135deg, #f3e5f5, #e1bee7);
            border: 2px solid #9c27b0;
        }

        .approach-card h4 {
            text-align: center;
            font-size: 1.3em;
            margin-bottom: 15px;
        }

        .approach-card.iterative h4 { color: #1565c0; }
        .approach-card.recursive h4 { color: #7b1fa2; }

        .approach-card ul {
            list-style: none;
            margin-left: 0;
        }

        .approach-card ul li {
            padding: 8px 0;
            padding-left: 25px;
            position: relative;
        }

        .approach-card ul li::before {
            position: absolute;
            left: 0;
            font-size: 1.1em;
        }

        .approach-card.iterative ul li::before { content: "-->"; color: #2196f3; }
        .approach-card.recursive ul li::before { content: "-->"; color: #9c27b0; }

        /* Demo Area */
        .demo-area {
            background: #f9f9f9;
            border: 2px solid #667eea;
            border-radius: 12px;
            padding: 30px;
            margin: 25px 0;
        }

        .demo-area h3 {
            text-align: center;
            margin-bottom: 20px;
        }

        .demo-layout {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            flex-wrap: wrap;
            justify-content: center;
        }

        .demo-code-panel {
            flex: 1;
            min-width: 300px;
        }

        .demo-stack-panel {
            flex: 0 0 260px;
        }

        .demo-output-panel {
            flex: 1;
            min-width: 250px;
        }

        /* Execution Highlight */
        .exec-line {
            padding: 2px 8px;
            margin: 1px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            border-radius: 3px;
            transition: background 0.3s;
        }

        .exec-line.active {
            background: rgba(255, 235, 59, 0.3);
            border-left: 3px solid #ffd700;
        }

        .exec-line.executed {
            background: rgba(76, 175, 80, 0.15);
        }

        /* Memory Diagram */
        .memory-diagram {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .memory-section {
            text-align: center;
        }

        .memory-section h4 {
            margin-bottom: 10px;
        }

        .memory-block {
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 15px;
            min-width: 200px;
            background: white;
        }

        /* Flow Arrow */
        .flow-arrow {
            font-size: 2em;
            color: #667eea;
            text-align: center;
            margin: 15px 0;
        }

        /* Step Counter */
        .step-indicator {
            text-align: center;
            font-size: 1.1em;
            color: #667eea;
            font-weight: bold;
            margin: 10px 0;
        }

        /* Footer */
        footer {
            background: #2d2d2d;
            color: white;
            text-align: center;
            padding: 20px;
        }

        footer p {
            margin: 5px 0;
        }

        /* Back Home Button */
        .back-home-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            text-decoration: none;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            transition: all 0.3s;
            z-index: 1000;
        }

        .back-home-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .content {
                padding: 20px;
            }

            header h1 {
                font-size: 1.8em;
            }

            h2 { font-size: 1.5em; }

            .demo-layout {
                flex-direction: column;
            }

            .demo-stack-panel {
                flex: 1;
            }

            .approach-cards {
                flex-direction: column;
            }

            .stack-box {
                width: 220px;
            }

            .stack-frame {
                width: 190px;
                font-size: 0.8em;
                padding: 6px;
            }
        }

        /* Scroll animation */
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        section {
            animation: fadeInUp 0.5s ease;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-home-btn">Home</a>
    <div class="container">
        <header>
            <div class="header-content">
                <img src="../fcit.png" alt="FCIT Logo">
                <div class="header-text">
                    <h1>Recursion</h1>
                    <p>CPCS 204 - Data Structures I</p>
                    <p>Understanding the Recursive Method</p>
                </div>
            </div>
        </header>

        <div class="content">

            <!-- ===================== SECTION 1: Introduction ===================== -->
            <section id="introduction">
                <h2>1. Introduction</h2>

                <div class="teacher-says">
                    Today, my students, we are going to learn something which is maybe new for you. Something called <strong>Recursion</strong> or the <strong>Recursive Method</strong>. But before we jump into this concept, I think we need to discuss something important first.
                </div>

                <p>Before we can understand recursion, we need to revisit something fundamental: <strong>how programs actually run in memory</strong>. Once we understand this, recursion will make much more sense.</p>

                <div class="highlight-box">
                    <strong>What we will cover today:</strong>
                    <ol>
                        <li>How programs execute in memory (the Call Stack)</li>
                        <li>Counting with loops (iterative approach)</li>
                        <li>Counting without loops (multiple methods)</li>
                        <li>The idea of a method calling itself</li>
                        <li>What is Recursion?</li>
                        <li>Iterative vs. Recursive &mdash; comparison and when to use each</li>
                    </ol>
                </div>
            </section>

            <!-- ===================== SECTION 2: How Programs Run in Memory ===================== -->
            <section id="memory">
                <h2>2. How Programs Run in Memory</h2>

                <div class="teacher-says">
                    As we all know, when we write a program and run it, the program is loaded into memory. Let us think about this in Java.
                </div>

                <p>Consider a simple Java program. We have a <code>main</code> method, and inside it we call another method called <code>printing()</code> that prints <strong>"Welcome to Java"</strong>.</p>

                <div class="code-container">
                    <div class="code-header" onclick="toggleCode(this)">
                        Java - Simple Method Call
                        <span class="code-toggle collapsed">&#9660;</span>
                    </div>
                    <div class="code-block collapsed"><span class="keyword">public class</span> <span class="class-name">MyProgram</span> {

    <span class="keyword">public static void</span> <span class="method">main</span>(String[] args) {
        <span class="method">printing</span>();  <span class="comment">// Call the printing method</span>
    }

    <span class="keyword">public static void</span> <span class="method">printing</span>() {
        System.out.println(<span class="string">"Welcome to Java"</span>);
    }
}</div>
                </div>

                <h3>Visualizing the Call Stack</h3>

                <div class="teacher-says">
                    Now, I want you to imagine a rectangle that is open from the top. This represents the <strong>Call Stack</strong> in memory. When <code>main()</code> starts, it goes onto the stack. When <code>main()</code> calls <code>printing()</code>, the <code>printing()</code> method is placed <em>on top</em> of <code>main()</code> in the stack.
                </div>

                <div class="important">
                    <strong>Remember:</strong> The Call Stack follows <strong>Last-In, First-Out (LIFO)</strong> order. The method on top executes first. When it finishes, it is removed (popped) from the stack, and execution returns to the method below it.
                </div>

                <div class="demo-area">
                    <h3>Animation: Simple Method Call Stack</h3>
                    <div class="demo-layout">
                        <div class="demo-code-panel">
                            <h4>Code Execution</h4>
                            <div id="simple-code-lines" style="background: #2d2d2d; padding: 15px; border-radius: 8px; color: #f8f8f2;">
                                <div class="exec-line" id="s-line-1"><span style="color:#6272a4;">// Program starts</span></div>
                                <div class="exec-line" id="s-line-2"><span style="color:#ff79c6;">public static void</span> <span style="color:#8be9fd;">main</span>(...) {</div>
                                <div class="exec-line" id="s-line-3">&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8be9fd;">printing</span>();</div>
                                <div class="exec-line" id="s-line-4">}</div>
                                <div class="exec-line" id="s-line-5"><span style="color:#ff79c6;">public static void</span> <span style="color:#8be9fd;">printing</span>() {</div>
                                <div class="exec-line" id="s-line-6">&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span style="color:#f1fa8c;">"Welcome to Java"</span>);</div>
                                <div class="exec-line" id="s-line-7">}</div>
                            </div>
                        </div>
                        <div class="demo-stack-panel">
                            <div class="stack-box-label">STACK</div>
                            <div class="stack-box" id="simple-stack">
                                <div class="stack-box-empty">( empty )</div>
                            </div>
                        </div>
                        <div class="demo-output-panel">
                            <h4>Output</h4>
                            <div class="output-console" id="simple-output">
                                <div class="output-header">--- Console ---</div>
                            </div>
                        </div>
                    </div>
                    <div class="narration" id="simple-narration">Press "Run" to start, then click "Next" to go step by step.</div>
                    <div class="step-indicator" id="simple-step"></div>
                    <div class="animation-controls">
                        <button class="btn" id="simple-run-btn" onclick="startSimpleAnimation()">Run</button>
                        <button class="btn btn-success" id="simple-next-btn" onclick="nextSimpleStep()" style="display:none;">Next</button>
                        <button class="btn btn-warning" onclick="resetSimpleAnimation()">Reset</button>
                    </div>
                </div>

                <div class="highlight-box">
                    <strong>Key Takeaway:</strong> Every time a method is called, a new <strong>frame</strong> is pushed onto the call stack. When the method finishes, its frame is <strong>popped off</strong>. This is how the computer keeps track of where it is in the program.
                </div>
            </section>

            <!-- ===================== SECTION 3: Counting with a Loop ===================== -->
            <section id="loop">
                <h2>3. Counting with a Loop</h2>

                <div class="teacher-says">
                    Now, let us write a simple program. I want to count from 1 to 5 and print each number. This is very simple &mdash; we use a <strong>for loop</strong>.
                </div>

                <div class="code-container">
                    <div class="code-header" onclick="toggleCode(this)">
                        Java - Counting with a For Loop
                        <span class="code-toggle collapsed">&#9660;</span>
                    </div>
                    <div class="code-block collapsed"><span class="keyword">public class</span> <span class="class-name">CountLoop</span> {

    <span class="keyword">public static void</span> <span class="method">main</span>(String[] args) {
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <= <span class="number">5</span>; i++) {
            System.out.println(<span class="string">"Counter: "</span> + i);
        }
    }
}</div>
                </div>

                <div class="demo-area">
                    <h3>Output Preview</h3>
                    <div class="output-console">
                        <div class="output-header">--- Console ---</div>
                        <div class="output-line">Counter: 1</div>
                        <div class="output-line">Counter: 2</div>
                        <div class="output-line">Counter: 3</div>
                        <div class="output-line">Counter: 4</div>
                        <div class="output-line">Counter: 5</div>
                    </div>
                </div>

                <div class="definition">
                    <strong>Simple and clean!</strong> The <code>for</code> loop repeats the print statement 5 times, incrementing <code>i</code> by 1 each time. This is the <strong>iterative</strong> approach &mdash; using repetition structures like loops.
                </div>
            </section>

            <!-- ===================== SECTION 4: Counting WITHOUT a Loop ===================== -->
            <section id="no-loop">
                <h2>4. What If We Don't Use a Loop?</h2>

                <div class="teacher-says">
                    OK, my students, you are happy with the loop. That is great! But now imagine... what if I tell you: <strong>do NOT use a loop</strong>. How would you count from 1 to 5?
                </div>

                <div class="student-says">
                    What can we use instead, Professor?
                </div>

                <div class="teacher-says">
                    Let me show you. What if I create <strong>five separate counter methods</strong>? Each method is responsible for printing one number and then calling the next method.
                </div>

                <div class="code-container">
                    <div class="code-header" onclick="toggleCode(this)">
                        Java - Five Separate Counter Methods
                        <span class="code-toggle collapsed">&#9660;</span>
                    </div>
                    <div class="code-block collapsed"><span class="keyword">public class</span> <span class="class-name">CountNoLoop</span> {

    <span class="keyword">public static void</span> <span class="method">main</span>(String[] args) {
        <span class="keyword">int</span> n = <span class="number">0</span>;
        <span class="method">counter1</span>(n);  <span class="comment">// Start with counter1, pass n = 0</span>
    }

    <span class="keyword">public static void</span> <span class="method">counter1</span>(<span class="keyword">int</span> n) {
        n = n + <span class="number">1</span>;            <span class="comment">// n becomes 1</span>
        <span class="method">counter2</span>(n);          <span class="comment">// Call counter2 FIRST, pass n = 1</span>
        System.out.println(<span class="string">"Counter: "</span> + n);  <span class="comment">// Print AFTER counter2 returns</span>
    }

    <span class="keyword">public static void</span> <span class="method">counter2</span>(<span class="keyword">int</span> n) {
        n = n + <span class="number">1</span>;            <span class="comment">// n becomes 2</span>
        <span class="method">counter3</span>(n);          <span class="comment">// Call counter3 FIRST, pass n = 2</span>
        System.out.println(<span class="string">"Counter: "</span> + n);  <span class="comment">// Print AFTER counter3 returns</span>
    }

    <span class="keyword">public static void</span> <span class="method">counter3</span>(<span class="keyword">int</span> n) {
        n = n + <span class="number">1</span>;            <span class="comment">// n becomes 3</span>
        <span class="method">counter4</span>(n);          <span class="comment">// Call counter4 FIRST, pass n = 3</span>
        System.out.println(<span class="string">"Counter: "</span> + n);  <span class="comment">// Print AFTER counter4 returns</span>
    }

    <span class="keyword">public static void</span> <span class="method">counter4</span>(<span class="keyword">int</span> n) {
        n = n + <span class="number">1</span>;            <span class="comment">// n becomes 4</span>
        <span class="method">counter5</span>(n);          <span class="comment">// Call counter5 FIRST, pass n = 4</span>
        System.out.println(<span class="string">"Counter: "</span> + n);  <span class="comment">// Print AFTER counter5 returns</span>
    }

    <span class="keyword">public static void</span> <span class="method">counter5</span>(<span class="keyword">int</span> n) {
        n = n + <span class="number">1</span>;            <span class="comment">// n becomes 5</span>
        <span class="comment">// No more methods to call, so print immediately</span>
        System.out.println(<span class="string">"Counter: "</span> + n);
    }
}</div>
                </div>

                <h3>Let's Visualize the Call Stack!</h3>

                <div class="teacher-says">
                    Now let me show you what happens in memory. Watch how each method goes onto the stack as it is called, and how they all come off when they finish.
                </div>

                <div class="demo-area">
                    <h3>Animation: Five Counter Methods on the Stack</h3>
                    <div class="demo-layout">
                        <div class="demo-code-panel">
                            <h4>What's Happening</h4>
                            <div id="counter-code-lines" style="background: #2d2d2d; padding: 15px; border-radius: 8px; color: #f8f8f2;">
                                <div class="exec-line" id="c-line-1">main() sets n=0, calls counter1(0)</div>
                                <div class="exec-line" id="c-line-2">counter1(0): n=1, calls counter2(1)</div>
                                <div class="exec-line" id="c-line-3">counter2(1): n=2, calls counter3(2)</div>
                                <div class="exec-line" id="c-line-4">counter3(2): n=3, calls counter4(3)</div>
                                <div class="exec-line" id="c-line-5">counter4(3): n=4, calls counter5(4)</div>
                                <div class="exec-line" id="c-line-6">counter5(4): n=5, prints 5 (last one!)</div>
                                <div class="exec-line" id="c-line-7"><span style="color:#6272a4;">-- Unwinding: each method prints when popped --</span></div>
                            </div>
                        </div>
                        <div class="demo-stack-panel">
                            <div class="stack-box-label">STACK</div>
                            <div class="stack-box" id="counter-stack">
                                <div class="stack-box-empty">( empty )</div>
                            </div>
                        </div>
                        <div class="demo-output-panel">
                            <h4>Output</h4>
                            <div class="output-console" id="counter-output">
                                <div class="output-header">--- Console ---</div>
                            </div>
                        </div>
                    </div>
                    <div class="narration" id="counter-narration">Press "Run" to start, then click "Next" to go step by step.</div>
                    <div class="step-indicator" id="counter-step"></div>
                    <div class="animation-controls">
                        <button class="btn" id="counter-run-btn" onclick="startCounterAnimation()">Run</button>
                        <button class="btn btn-success" id="counter-next-btn" onclick="nextCounterStep()" style="display:none;">Next</button>
                        <button class="btn btn-warning" onclick="resetCounterAnimation()">Reset</button>
                    </div>
                </div>

                <h3>But What About 100?</h3>

                <div class="teacher-says">
                    My students, this worked well for 5 numbers. But what if I ask you to count to <strong>100</strong>? That means you need to create <strong>100 separate methods</strong>! counter1(), counter2(), counter3(), ... all the way to counter100(). This is not practical at all!
                </div>

                <div class="warning">
                    <strong>The Problem:</strong> Creating 100 copies of essentially the same method is:
                    <ul>
                        <li>Extremely tedious and error-prone</li>
                        <li>Not scalable &mdash; what if we need 1000?</li>
                        <li>A violation of good programming principles (DRY - Don't Repeat Yourself)</li>
                    </ul>
                </div>

                <div class="student-says">
                    So Professor, isn't there a way to have <strong>one method</strong> that does the same work?
                </div>
            </section>

            <!-- ===================== SECTION 5: A Method Calling Itself ===================== -->
            <section id="self-call">
                <h2>5. One Method That Calls Itself</h2>

                <div class="teacher-says">
                    Excellent question! What if I create only <strong>one version</strong> of the counter method? This single method increases the counter by one and then <strong>calls itself</strong>!
                </div>

                <div class="code-container">
                    <div class="code-header" onclick="toggleCode(this)">
                        Java - A Method That Calls Itself
                        <span class="code-toggle collapsed">&#9660;</span>
                    </div>
                    <div class="code-block collapsed"><span class="keyword">public class</span> <span class="class-name">CountRecursive</span> {

    <span class="keyword">public static void</span> <span class="method">main</span>(String[] args) {
        <span class="method">counter</span>(<span class="number">1</span>);  <span class="comment">// Start counting from 1</span>
    }

    <span class="keyword">public static void</span> <span class="method">counter</span>(<span class="keyword">int</span> n) {
        <span class="keyword">if</span> (n <= <span class="number">5</span>) {                          <span class="comment">// Base case: stop when n > 5</span>
            <span class="method">counter</span>(n + <span class="number">1</span>);                      <span class="comment">// Call itself FIRST with n+1</span>
            System.out.println(<span class="string">"Counter: "</span> + n);  <span class="comment">// Print AFTER the recursive call returns</span>
        }
    }
}</div>
                </div>

                <h3>Let's See It in Memory!</h3>

                <div class="teacher-says">
                    Now, let me show you what happens in the memory. It is very important to see how this works. Watch carefully &mdash; you will notice something similar to our 5 counter methods, but now it is the <strong>same method calling itself</strong> each time!
                </div>

                <div class="demo-area">
                    <h3>Animation: Recursive Counter on the Stack</h3>
                    <div class="demo-layout">
                        <div class="demo-code-panel">
                            <h4>Code (one method!)</h4>
                            <div style="background: #2d2d2d; padding: 15px; border-radius: 8px; color: #f8f8f2; font-family: 'Courier New', monospace; font-size: 0.85em;">
                                <div class="exec-line" id="r-line-1"><span style="color:#ff79c6;">public static void</span> <span style="color:#8be9fd;">counter</span>(<span style="color:#ff79c6;">int</span> n) {</div>
                                <div class="exec-line" id="r-line-2">&nbsp;&nbsp;<span style="color:#ff79c6;">if</span> (n <= <span style="color:#bd93f9;">5</span>) {</div>
                                <div class="exec-line" id="r-line-3">&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8be9fd;">counter</span>(n + <span style="color:#bd93f9;">1</span>); <span style="color:#6272a4;">// call FIRST</span></div>
                                <div class="exec-line" id="r-line-4">&nbsp;&nbsp;&nbsp;&nbsp;println(<span style="color:#f1fa8c;">"Counter: "</span>+ n); <span style="color:#6272a4;">// print AFTER</span></div>
                                <div class="exec-line" id="r-line-5">&nbsp;&nbsp;}</div>
                                <div class="exec-line" id="r-line-6">}</div>
                            </div>
                        </div>
                        <div class="demo-stack-panel">
                            <div class="stack-box-label">STACK</div>
                            <div class="stack-box" id="recursive-stack">
                                <div class="stack-box-empty">( empty )</div>
                            </div>
                        </div>
                        <div class="demo-output-panel">
                            <h4>Output</h4>
                            <div class="output-console" id="recursive-output">
                                <div class="output-header">--- Console ---</div>
                            </div>
                        </div>
                    </div>
                    <div class="narration" id="recursive-narration">Press "Run" to start, then click "Next" to go step by step.</div>
                    <div class="step-indicator" id="recursive-step"></div>
                    <div class="animation-controls">
                        <button class="btn" id="recursive-run-btn" onclick="startRecursiveAnimation()">Run</button>
                        <button class="btn btn-success" id="recursive-next-btn" onclick="nextRecursiveStep()" style="display:none;">Next</button>
                        <button class="btn btn-warning" onclick="resetRecursiveAnimation()">Reset</button>
                    </div>
                </div>

                <div class="highlight-box">
                    <strong>Notice:</strong> The output is <strong>5, 4, 3, 2, 1</strong> (reverse order!) because each method calls itself <em>first</em> and prints <em>after</em> the recursive call returns. The printing happens during the <strong>unwinding phase</strong> when each frame is popped off the stack. We only wrote <strong>one method</strong>, and each call has its own copy of <code>n</code> on the stack.
                </div>
            </section>

            <!-- ===================== SECTION 6: The Danger - No Termination ===================== -->
            <section id="danger">
                <h2>6. The Danger: No Termination!</h2>

                <div class="teacher-says">
                    Yes, my students, this is wonderful! But let me ask you a very important question: what happens if the method calls itself <strong>many, many times without ever stopping</strong>? What if we remove the condition <code>if (n &lt;= 5)</code>?
                </div>

                <div class="code-container">
                    <div class="code-header" onclick="toggleCode(this)">
                        Java - Infinite Recursion (DANGER!)
                        <span class="code-toggle collapsed">&#9660;</span>
                    </div>
                    <div class="code-block collapsed"><span class="keyword">public class</span> <span class="class-name">InfiniteRecursion</span> {

    <span class="keyword">public static void</span> <span class="method">main</span>(String[] args) {
        <span class="method">counter</span>(<span class="number">1</span>);
    }

    <span class="keyword">public static void</span> <span class="method">counter</span>(<span class="keyword">int</span> n) {
        System.out.println(<span class="string">"Counter: "</span> + n);
        <span class="method">counter</span>(n + <span class="number">1</span>);  <span class="comment">// No stopping condition!</span>
        <span class="comment">// This method will call itself FOREVER!</span>
    }
}</div>
                </div>

                <div class="demo-area">
                    <h3>Animation: Stack Overflow!</h3>
                    <div class="demo-layout">
                        <div class="demo-stack-panel" style="flex: 0 0 280px;">
                            <div class="stack-box-label">STACK</div>
                            <div class="stack-box" id="overflow-stack" style="transition: all 0.5s;">
                                <div class="stack-box-empty">( empty )</div>
                            </div>
                        </div>
                        <div class="demo-output-panel">
                            <h4>Output</h4>
                            <div class="output-console" id="overflow-output" style="max-height: 200px; overflow-y: auto;">
                                <div class="output-header">--- Console ---</div>
                            </div>
                            <div id="overflow-error" style="display:none; margin-top:15px;">
                                <div class="warning" style="background: #ffebee; border-left-color: #f44336;">
                                    <strong style="color:#f44336;">Exception in thread "main"<br>java.lang.StackOverflowError</strong>
                                    <p style="margin-top:10px;">The stack ran out of memory! The program has crashed.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="narration" id="overflow-narration">Press "Run" to start, then click "Next" to see each call fill the stack.</div>
                    <div class="step-indicator" id="overflow-step"></div>
                    <div class="animation-controls">
                        <button class="btn btn-danger" id="overflow-run-btn" onclick="startOverflowAnimation()">Run (Danger!)</button>
                        <button class="btn btn-danger" id="overflow-next-btn" onclick="nextOverflowStep()" style="display:none;">Next</button>
                        <button class="btn btn-warning" onclick="resetOverflowAnimation()">Reset</button>
                    </div>
                </div>

                <div class="warning">
                    <strong>Stack Overflow!</strong> Without a stopping condition, the method keeps calling itself infinitely. Each call adds a new frame to the stack. Eventually, the stack runs <strong>out of memory</strong>, and the program <strong>crashes</strong> with a <code>StackOverflowError</code>.
                </div>

                <div class="important">
                    <strong>This is similar to an infinite loop!</strong>
                    <ul>
                        <li>An infinite <strong>loop</strong> runs forever but uses the same memory space.</li>
                        <li>An infinite <strong>recursion</strong> also runs forever, but each call uses <strong>new memory</strong> on the stack &mdash; so it eventually <strong>destroys the stack</strong> and crashes the program!</li>
                    </ul>
                </div>
            </section>

            <!-- ===================== SECTION 7: What is Recursion? ===================== -->
            <section id="definition">
                <h2>7. What is Recursion?</h2>

                <div class="definition">
                    <strong>Recursion</strong> is a programming technique where a method <strong>calls itself</strong> to solve a problem. Each call works on a smaller version of the same problem until it reaches a <strong>base case</strong> (a condition where the method stops calling itself and returns a result).
                </div>

                <h3>The Two Essential Parts of Recursion</h3>

                <div class="approach-cards">
                    <div class="approach-card" style="background: linear-gradient(135deg, #e8f5e9, #c8e6c9); border-color: #4caf50;">
                        <h4 style="color: #2e7d32;">1. Base Case (Stopping Condition)</h4>
                        <p>This is the condition that <strong>stops</strong> the recursion. Without it, you get infinite recursion and a stack overflow!</p>
                        <div style="background: #2d2d2d; padding: 12px; border-radius: 6px; margin-top: 10px;">
                            <code style="color: #f8f8f2; font-size: 0.9em;"><span style="color:#ff79c6;">if</span> (n > <span style="color:#bd93f9;">5</span>) <span style="color:#ff79c6;">return</span>; <span style="color:#6272a4;">// STOP!</span></code>
                        </div>
                    </div>
                    <div class="approach-card" style="background: linear-gradient(135deg, #fff3e0, #ffe0b2); border-color: #ff9800;">
                        <h4 style="color: #e65100;">2. Recursive Case (Self-Call)</h4>
                        <p>This is where the method <strong>calls itself</strong> with modified parameters, moving toward the base case.</p>
                        <div style="background: #2d2d2d; padding: 12px; border-radius: 6px; margin-top: 10px;">
                            <code style="color: #f8f8f2; font-size: 0.9em;"><span style="color:#8be9fd;">counter</span>(n + <span style="color:#bd93f9;">1</span>); <span style="color:#6272a4;">// Call itself</span></code>
                        </div>
                    </div>
                </div>

                <div class="definition">
                    <strong>Recursive Method:</strong> A method that calls itself, directly or indirectly, to solve a problem by breaking it into smaller sub-problems of the same type.
                </div>
            </section>

            <!-- ===================== SECTION 8: Iterative vs Recursive ===================== -->
            <section id="comparison">
                <h2>8. Iterative vs. Recursive</h2>

                <div class="teacher-says">
                    My students, now that we understand recursion, a very important question comes up: <strong>when should we use loops (iterative) and when should we use recursion?</strong> Can we always use either one?
                </div>

                <div class="student-says">
                    Doctor, can we use both the iterative process and recursion for the same problem?
                </div>

                <div class="teacher-says">
                    <strong>Yes, you can!</strong> Anything that can be solved with iteration can be solved with recursion, and vice versa. But &mdash; and this is a big "but" &mdash; there are important differences.
                </div>

                <h3>Side-by-Side Comparison</h3>

                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>Iterative (Loops)</th>
                            <th>Recursive</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>How it repeats</strong></td>
                            <td>Uses loop statements<br>(for, while, do-while)</td>
                            <td>Method calls itself</td>
                        </tr>
                        <tr>
                            <td><strong>Termination</strong></td>
                            <td>Loop condition becomes false</td>
                            <td>Base case is reached</td>
                        </tr>
                        <tr>
                            <td><strong>Infinite execution</strong></td>
                            <td>Infinite loop<br>(program hangs)</td>
                            <td>Stack overflow<br>(program crashes!)</td>
                        </tr>
                        <tr>
                            <td><strong>Memory usage</strong></td>
                            <td>Uses the same memory space</td>
                            <td>Each call uses NEW stack memory</td>
                        </tr>
                        <tr>
                            <td><strong>Efficiency</strong></td>
                            <td>Generally more efficient</td>
                            <td>More memory-consuming</td>
                        </tr>
                        <tr>
                            <td><strong>Code readability</strong></td>
                            <td>Can be complex for some problems</td>
                            <td>Elegant for some problems</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Which is Better?</h3>

                <div class="student-says">
                    Doctor, which is better? When should we use iterative or recursion?
                </div>

                <div class="teacher-says">
                    My students, you must know that recursion is <strong>more memory-consuming</strong>. If you write your code with loops, absolutely it is more efficient than recursion. So why do we even learn recursion?
                </div>

                <div class="highlight-box">
                    <strong>Why learn recursion?</strong>
                    <p>Because there are some problems that are <strong>very challenging to solve with loops</strong> but become <strong>much easier with recursion</strong>.</p>
                    <p style="margin-top: 15px;">For example:</p>
                    <ul>
                        <li><strong>Exploring file systems</strong> &mdash; folders inside folders inside folders (arbitrary depth)</li>
                        <li><strong>Tree data structures</strong> &mdash; traversing nodes with unpredictable depth</li>
                        <li><strong>Divide and conquer algorithms</strong> &mdash; breaking problems into smaller identical sub-problems</li>
                        <li><strong>Mathematical definitions</strong> &mdash; factorial, Fibonacci, power functions</li>
                    </ul>
                </div>

                <div class="important">
                    <strong>Important Agreement:</strong>
                    <ul>
                        <li>Anything that can be solved by <strong>iteration</strong> can also be solved by <strong>recursion</strong>.</li>
                        <li>Anything that can be solved by <strong>recursion</strong> can also be solved by <strong>iteration</strong>.</li>
                        <li>But sometimes, as humans and programmers, we <strong>prefer recursion</strong> because it makes certain complex problems much easier to think about and code.</li>
                    </ul>
                </div>

                <div class="teacher-says">
                    In the next study, I will give you some scenarios and problems that will <strong>motivate you</strong> to see why we sometimes strongly prefer the recursive approach. I will show you cases that are very challenging to solve with loops but become elegant with recursion. Stay tuned!
                </div>
            </section>

            <!-- ===================== SECTION 9: Summary ===================== -->
            <section id="summary">
                <h2>9. Summary</h2>

                <div class="highlight-box" style="background: linear-gradient(135deg, #667eea15, #764ba215); border-left-color: #764ba2;">
                    <h3 style="margin-top: 0;">What We Learned Today</h3>
                    <ol>
                        <li><strong>The Call Stack</strong> &mdash; When a method is called, a frame is pushed onto the stack. When it returns, the frame is popped off.</li>
                        <li><strong>Iterative approach</strong> &mdash; Using loops (for, while) to repeat a process.</li>
                        <li><strong>Multiple methods approach</strong> &mdash; Creating many similar methods is impractical and does not scale.</li>
                        <li><strong>A method can call itself</strong> &mdash; This is the foundation of recursion.</li>
                        <li><strong>Without a base case</strong> &mdash; Infinite recursion leads to StackOverflowError (the stack memory is exhausted).</li>
                        <li><strong>Recursion</strong> = Base Case + Recursive Case.</li>
                        <li><strong>Iteration vs. Recursion</strong> &mdash; Both can solve the same problems. Iteration is more memory-efficient, but recursion can be more natural for complex problems like trees and file systems.</li>
                    </ol>
                </div>

                <div class="teacher-says">
                    Excellent work today, my students! Make sure you understand the Call Stack and how recursion works in memory. In the next tutorial, I will show you exciting examples where recursion truly shines!
                </div>
            </section>

        </div>

        <div style="text-align: center; padding: 25px 40px; color: #6b7280; font-size: 0.9rem; border-top: 1px solid #e5e7eb; line-height: 1.8;">
            <div style="font-weight: bold; color: #1f2937; font-size: 1rem;">King Abdulaziz University</div>
            <div>Faculty of Computing and Information Technology (FCIT)</div>
            <div style="margin-top: 8px;">Prepared by Dr. Abdulmohsen Almalawi</div>
        </div>
    </div>

    <script>
        // ==================== Code Toggle ====================
        function toggleCode(header) {
            const codeBlock = header.nextElementSibling;
            const toggle = header.querySelector('.code-toggle');
            codeBlock.classList.toggle('collapsed');
            toggle.classList.toggle('collapsed');
        }

        // ==================== Helper Functions ====================
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function clearHighlights(prefix, count) {
            for (let i = 1; i <= count; i++) {
                const el = document.getElementById(prefix + '-line-' + i);
                if (el) {
                    el.classList.remove('active', 'executed');
                }
            }
        }

        function highlightLine(prefix, lineNum) {
            const el = document.getElementById(prefix + '-line-' + lineNum);
            if (el) {
                el.classList.add('active');
            }
        }

        function markExecuted(prefix, lineNum) {
            const el = document.getElementById(prefix + '-line-' + lineNum);
            if (el) {
                el.classList.remove('active');
                el.classList.add('executed');
            }
        }

        function addStackFrame(stackId, text, frameClass) {
            const stack = document.getElementById(stackId);
            // Remove empty placeholder if present
            const empty = stack.querySelector('.stack-box-empty');
            if (empty) empty.remove();
            // Insert at the TOP (first child) since column layout = top-to-bottom
            const frame = document.createElement('div');
            frame.className = 'stack-frame ' + frameClass;
            frame.textContent = text;
            stack.insertBefore(frame, stack.firstChild);
            return frame;
        }

        function removeTopFrame(stackId) {
            const stack = document.getElementById(stackId);
            const frames = stack.querySelectorAll('.stack-frame');
            if (frames.length > 0) {
                // Top of stack = first child
                const top = frames[0];
                top.style.animation = 'popFrame 0.4s ease forwards';
                return new Promise(resolve => {
                    setTimeout(() => {
                        top.remove();
                        resolve();
                    }, 400);
                });
            }
            return Promise.resolve();
        }

        function addOutput(outputId, text) {
            const output = document.getElementById(outputId);
            const line = document.createElement('div');
            line.className = 'output-line';
            line.textContent = text;
            output.appendChild(line);
        }

        function setNarration(narrationId, text) {
            document.getElementById(narrationId).innerHTML = text;
        }

        function setStep(stepId, text) {
            document.getElementById(stepId).textContent = text;
        }

        // ==================== Animation 1: Simple Method Call ====================
        let simpleCurrentStep = 0;

        function startSimpleAnimation() {
            resetSimpleAnimation();
            document.getElementById('simple-run-btn').style.display = 'none';
            document.getElementById('simple-next-btn').style.display = '';
            setNarration('simple-narration', 'Ready! Click <strong>Next</strong> to step through the execution.');
            setStep('simple-step', 'Step 0 of 6');
        }

        async function nextSimpleStep() {
            const btn = document.getElementById('simple-next-btn');
            btn.disabled = true;
            simpleCurrentStep++;

            switch (simpleCurrentStep) {
                case 1:
                    setNarration('simple-narration', 'The program starts. <strong>main()</strong> is pushed onto the Call Stack.');
                    setStep('simple-step', 'Step 1 of 6');
                    highlightLine('s', 2);
                    addStackFrame('simple-stack', 'main()', 'main-frame');
                    break;
                case 2:
                    markExecuted('s', 2);
                    setNarration('simple-narration', '<strong>main()</strong> calls <strong>printing()</strong>. A new frame is pushed on top.');
                    setStep('simple-step', 'Step 2 of 6');
                    highlightLine('s', 3);
                    break;
                case 3:
                    addStackFrame('simple-stack', 'printing()', 'method-frame');
                    markExecuted('s', 3);
                    setNarration('simple-narration', '<strong>printing()</strong> is now on top of the stack. It will execute first (LIFO).');
                    setStep('simple-step', 'Step 3 of 6');
                    highlightLine('s', 5);
                    highlightLine('s', 6);
                    break;
                case 4:
                    markExecuted('s', 5);
                    markExecuted('s', 6);
                    addOutput('simple-output', 'Welcome to Java');
                    setNarration('simple-narration', '<strong>printing()</strong> executes: prints <em>"Welcome to Java"</em> to the console.');
                    setStep('simple-step', 'Step 4 of 6');
                    break;
                case 5:
                    setNarration('simple-narration', '<strong>printing()</strong> finishes. Its frame is <strong>popped off</strong> the stack.');
                    setStep('simple-step', 'Step 5 of 6');
                    highlightLine('s', 7);
                    await removeTopFrame('simple-stack');
                    break;
                case 6:
                    markExecuted('s', 7);
                    markExecuted('s', 4);
                    setNarration('simple-narration', '<strong>main()</strong> has nothing left to do. It is popped off. Program ends.');
                    setStep('simple-step', 'Step 6 of 6');
                    await removeTopFrame('simple-stack');
                    break;
                default:
                    setNarration('simple-narration', 'Program finished! The stack is empty.');
                    setStep('simple-step', 'Complete!');
                    btn.textContent = 'Done';
                    btn.disabled = true;
                    return;
            }
            await delay(300);
            btn.disabled = false;
        }

        function resetSimpleAnimation() {
            simpleCurrentStep = 0;
            document.getElementById('simple-stack').innerHTML = '<div class="stack-box-empty">( empty )</div>';
            document.getElementById('simple-output').innerHTML = '<div class="output-header">--- Console ---</div>';
            clearHighlights('s', 7);
            setNarration('simple-narration', 'Press "Run" to start, then click "Next" to go step by step.');
            setStep('simple-step', '');
            document.getElementById('simple-run-btn').style.display = '';
            const nextBtn = document.getElementById('simple-next-btn');
            nextBtn.style.display = 'none';
            nextBtn.textContent = 'Next';
            nextBtn.disabled = false;
        }

        // ==================== Animation 2: Five Counter Methods ====================
        // Invocation is BEFORE print, so printing happens during stack unwinding
        let counterCurrentStep = 0;

        function startCounterAnimation() {
            resetCounterAnimation();
            document.getElementById('counter-run-btn').style.display = 'none';
            document.getElementById('counter-next-btn').style.display = '';
            setNarration('counter-narration', 'Ready! Click <strong>Next</strong> to step through. Notice: each method calls the next one <strong>before</strong> printing. Printing happens when the method is <strong>popped</strong> off the stack!');
            setStep('counter-step', 'Step 0 of 18');
        }

        async function nextCounterStep() {
            const btn = document.getElementById('counter-next-btn');
            btn.disabled = true;
            counterCurrentStep++;

            const frameClasses = ['counter-frame-1','counter-frame-2','counter-frame-3','counter-frame-4','counter-frame-5'];
            const nReceived = [0, 1, 2, 3, 4];
            const nAfter    = [1, 2, 3, 4, 5];

            // Steps 1: push main
            // Steps 2-6: push counter1..counter5 (each increments n, calls next BEFORE printing)
            // Step 7: counter5 has no next to call, prints immediately
            // Steps 8-11: pop counter5..counter2, each prints as it pops
            // Step 12: pop counter1, it prints
            // Step 13: pop main
            // Step 14: done

            if (counterCurrentStep === 1) {
                highlightLine('c', 1);
                setNarration('counter-narration', 'Program starts. <strong>main()</strong> sets <code>n = 0</code> and calls <strong>counter1(0)</strong>.');
                setStep('counter-step', 'Step 1 of 14');
                addStackFrame('counter-stack', 'main()  n=0', 'main-frame');
            } else if (counterCurrentStep >= 2 && counterCurrentStep <= 5) {
                // Push counter1..counter4 (they call next BEFORE printing)
                const i = counterCurrentStep - 1; // 1..4
                markExecuted('c', i);
                highlightLine('c', i + 1);
                const caller = i === 1 ? 'main()' : 'counter' + (i-1) + '()';
                setNarration('counter-narration',
                    '<strong>' + caller + '</strong> calls <strong>counter' + i + '(' + nReceived[i-1] + ')</strong>. Inside: <code>n = ' + nReceived[i-1] + ' + 1 = ' + nAfter[i-1] + '</code>. It calls <strong>counter' + (i+1) + '(' + nAfter[i-1] + ')</strong> <em>before</em> printing.');
                setStep('counter-step', 'Step ' + counterCurrentStep + ' of 14');
                addStackFrame('counter-stack', 'counter' + i + '()  n=' + nAfter[i-1], frameClasses[i-1]);
            } else if (counterCurrentStep === 6) {
                // Push counter5 (last one, prints immediately)
                markExecuted('c', 5);
                highlightLine('c', 6);
                setNarration('counter-narration',
                    '<strong>counter4()</strong> calls <strong>counter5(4)</strong>. Inside: <code>n = 4 + 1 = 5</code>. No more methods to call, so it prints <strong>immediately</strong>!');
                setStep('counter-step', 'Step 6 of 14');
                addStackFrame('counter-stack', 'counter5()  n=5', frameClasses[4]);
                await delay(300);
                addOutput('counter-output', 'Counter: 5');
            } else if (counterCurrentStep === 7) {
                // Start unwinding
                markExecuted('c', 6);
                highlightLine('c', 7);
                setNarration('counter-narration', '<strong>counter5()</strong> is done. Now the stack <strong>unwinds</strong>! Each method will print <em>as it is popped off</em>.');
                setStep('counter-step', 'Step 7 of 14');
            } else if (counterCurrentStep === 8) {
                // Pop counter5 (it already printed in step 6, just pop it)
                setNarration('counter-narration',
                    '<strong>counter5()</strong> is done (it already printed). It is <strong>popped off</strong> the stack.');
                setStep('counter-step', 'Step 8 of 14');
                await removeTopFrame('counter-stack');
            } else if (counterCurrentStep >= 9 && counterCurrentStep <= 11) {
                // Pop counter4..counter2, each prints as it is popped
                const i = 4 - (counterCurrentStep - 9); // 4, 3, 2
                const printVal = nAfter[i - 1];
                setNarration('counter-narration',
                    '<strong>counter' + i + '()</strong> resumes after counter' + (i+1) + '() returned. It now prints: <strong>"Counter: ' + printVal + '"</strong> and is popped off.');
                setStep('counter-step', 'Step ' + counterCurrentStep + ' of 14');
                addOutput('counter-output', 'Counter: ' + printVal);
                await delay(200);
                await removeTopFrame('counter-stack');
            } else if (counterCurrentStep === 12) {
                // Pop counter1, it prints
                setNarration('counter-narration',
                    '<strong>counter1()</strong> is popped off the stack. It prints: <strong>"Counter: 1"</strong>.');
                setStep('counter-step', 'Step 12 of 14');
                await removeTopFrame('counter-stack');
                addOutput('counter-output', 'Counter: 1');
            } else if (counterCurrentStep === 13) {
                // Pop main
                setNarration('counter-narration', '<strong>main()</strong> finishes. Program ends.');
                setStep('counter-step', 'Step 13 of 14');
                markExecuted('c', 7);
                await removeTopFrame('counter-stack');
            } else {
                setNarration('counter-narration', 'Program finished! Notice the output is <strong>5, 4, 3, 2, 1</strong> &mdash; because each method printed <em>after</em> the next one returned (when it was popped off the stack).');
                setStep('counter-step', 'Complete!');
                btn.textContent = 'Done';
                btn.disabled = true;
                return;
            }

            await delay(300);
            btn.disabled = false;
        }

        function resetCounterAnimation() {
            counterCurrentStep = 0;
            document.getElementById('counter-stack').innerHTML = '<div class="stack-box-empty">( empty )</div>';
            document.getElementById('counter-output').innerHTML = '<div class="output-header">--- Console ---</div>';
            clearHighlights('c', 7);
            setNarration('counter-narration', 'Press "Run" to start, then click "Next" to go step by step.');
            setStep('counter-step', '');
            document.getElementById('counter-run-btn').style.display = '';
            const nextBtn = document.getElementById('counter-next-btn');
            nextBtn.style.display = 'none';
            nextBtn.textContent = 'Next';
            nextBtn.disabled = false;
        }

        // ==================== Animation 3: Recursive Counter ====================
        let recursiveCurrentStep = 0;

        function startRecursiveAnimation() {
            resetRecursiveAnimation();
            document.getElementById('recursive-run-btn').style.display = 'none';
            document.getElementById('recursive-next-btn').style.display = '';
            setNarration('recursive-narration', 'Ready! Click <strong>Next</strong> to step through the recursive calls.');
            setStep('recursive-step', 'Step 0 of 14');
        }

        async function nextRecursiveStep() {
            const btn = document.getElementById('recursive-next-btn');
            btn.disabled = true;
            recursiveCurrentStep++;

            // Steps 1: push main
            // Steps 2-6: push counter(1)..counter(5)
            // Step 7: push counter(6) - base case, returns immediately
            // Step 8: pop counter(6)
            // Steps 9-13: pop counter(5)..counter(1)
            // Step 14: pop main
            // Step 15: done

            if (recursiveCurrentStep === 1) {
                setNarration('recursive-narration', 'Program starts. <strong>main()</strong> calls <strong>counter(1)</strong>.');
                setStep('recursive-step', 'Step 1 of 14');
                addStackFrame('recursive-stack', 'main()', 'main-frame');
            } else if (recursiveCurrentStep >= 2 && recursiveCurrentStep <= 6) {
                const n = recursiveCurrentStep - 1; // 1..5
                clearHighlights('r', 6);
                highlightLine('r', 1);
                highlightLine('r', 2);
                setNarration('recursive-narration',
                    '<strong>counter(' + n + ')</strong> is called. Since ' + n + ' &lt;= 5, it enters the if block and calls <strong>counter(' + (n+1) + ')</strong>.');
                setStep('recursive-step', 'Step ' + recursiveCurrentStep + ' of 14');
                addStackFrame('recursive-stack', 'counter(' + n + ')', 'recursive-frame');
                await delay(200);
                clearHighlights('r', 6);
                highlightLine('r', 4);
            } else if (recursiveCurrentStep === 7) {
                clearHighlights('r', 6);
                highlightLine('r', 1);
                highlightLine('r', 2);
                setNarration('recursive-narration',
                    '<strong>counter(6)</strong> is called. Since 6 &gt; 5, the if condition is <strong>FALSE</strong>. It returns immediately!');
                setStep('recursive-step', 'Step 7 of 14');
                addStackFrame('recursive-stack', 'counter(6)', 'main-frame');
            } else if (recursiveCurrentStep === 8) {
                clearHighlights('r', 6);
                highlightLine('r', 5);
                highlightLine('r', 6);
                setNarration('recursive-narration', '<strong>Base case reached!</strong> counter(6) is popped. Now the stack <strong>unwinds</strong> &mdash; each counter() will print as it is popped!');
                setStep('recursive-step', 'Step 8 of 14');
                await removeTopFrame('recursive-stack');
            } else if (recursiveCurrentStep >= 9 && recursiveCurrentStep <= 13) {
                const n = 5 - (recursiveCurrentStep - 9); // 5,4,3,2,1
                clearHighlights('r', 6);
                highlightLine('r', 3);
                setNarration('recursive-narration',
                    '<strong>counter(' + n + ')</strong> resumes after its recursive call returns. It prints <strong>"Counter: ' + n + '"</strong> and is popped off.');
                setStep('recursive-step', 'Step ' + recursiveCurrentStep + ' of 14');
                addOutput('recursive-output', 'Counter: ' + n);
                await delay(200);
                await removeTopFrame('recursive-stack');
            } else if (recursiveCurrentStep === 14) {
                clearHighlights('r', 6);
                setNarration('recursive-narration', '<strong>main()</strong> finishes. Program ends.');
                setStep('recursive-step', 'Step 14 of 14');
                await removeTopFrame('recursive-stack');
            } else {
                setNarration('recursive-narration', 'Program finished! One method called itself 5 times. The output is <strong>5, 4, 3, 2, 1</strong> because printing happens during the <strong>unwinding</strong> phase.');
                setStep('recursive-step', 'Complete!');
                btn.textContent = 'Done';
                btn.disabled = true;
                return;
            }

            await delay(300);
            btn.disabled = false;
        }

        function resetRecursiveAnimation() {
            recursiveCurrentStep = 0;
            document.getElementById('recursive-stack').innerHTML = '<div class="stack-box-empty">( empty )</div>';
            document.getElementById('recursive-output').innerHTML = '<div class="output-header">--- Console ---</div>';
            clearHighlights('r', 6);
            setNarration('recursive-narration', 'Press "Run" to start, then click "Next" to go step by step.');
            setStep('recursive-step', '');
            document.getElementById('recursive-run-btn').style.display = '';
            const nextBtn = document.getElementById('recursive-next-btn');
            nextBtn.style.display = 'none';
            nextBtn.textContent = 'Next';
            nextBtn.disabled = false;
        }

        // ==================== Animation 4: Stack Overflow ====================
        let overflowCurrentStep = 0;
        const overflowTotalFrames = 15;

        function startOverflowAnimation() {
            resetOverflowAnimation();
            document.getElementById('overflow-run-btn').style.display = 'none';
            document.getElementById('overflow-next-btn').style.display = '';
            setNarration('overflow-narration', 'Ready! Click <strong>Next</strong> to see each call pile onto the stack with NO stopping condition!');
            setStep('overflow-step', 'Step 0');
        }

        async function nextOverflowStep() {
            const btn = document.getElementById('overflow-next-btn');
            btn.disabled = true;
            overflowCurrentStep++;

            const stackEl = document.getElementById('overflow-stack');

            if (overflowCurrentStep === 1) {
                // Push main
                setNarration('overflow-narration', 'Program starts. <strong>main()</strong> calls <strong>counter(1)</strong> with <strong>NO stopping condition!</strong>');
                setStep('overflow-step', 'Frame 1 / ' + (overflowTotalFrames + 1));
                addStackFrame('overflow-stack', 'main()', 'main-frame');
            } else if (overflowCurrentStep >= 2 && overflowCurrentStep <= overflowTotalFrames + 1) {
                const n = overflowCurrentStep - 1;
                addStackFrame('overflow-stack', 'counter(' + n + ')', 'overflow-frame');
                addOutput('overflow-output', 'Counter: ' + n);
                setStep('overflow-step', 'Frame ' + overflowCurrentStep + ' / ' + (overflowTotalFrames + 1));

                if (n <= 5) {
                    setNarration('overflow-narration',
                        '<strong>counter(' + n + ')</strong> calls <strong>counter(' + (n+1) + ')</strong>... The stack keeps growing!');
                } else if (n <= 10) {
                    setNarration('overflow-narration',
                        'Still going... <strong>counter(' + n + ')</strong> calls <strong>counter(' + (n+1) + ')</strong>. The stack is getting full!');
                } else {
                    setNarration('overflow-narration',
                        '<strong style="color:#f44336;">WARNING:</strong> The stack is almost out of memory! counter(' + n + ') keeps calling...');
                }
            } else if (overflowCurrentStep === overflowTotalFrames + 2) {
                // Stack full - shake
                setNarration('overflow-narration', '<strong style="color:#f44336;">The stack is FULL! No more memory available!</strong>');
                setStep('overflow-step', 'Stack Full!');
                stackEl.style.animation = 'shake 0.5s ease';
                await delay(600);
                stackEl.style.animation = '';
            } else {
                // Crash
                stackEl.style.animation = 'explode 0.8s ease';
                stackEl.style.borderColor = '#f44336';
                document.getElementById('overflow-error').style.display = 'block';
                setNarration('overflow-narration', '<strong style="color:#f44336;">CRASH! java.lang.StackOverflowError</strong> &mdash; The program is terminated.');
                setStep('overflow-step', 'Stack Overflow!');
                await delay(500);
                stackEl.style.animation = '';
                addOutput('overflow-output', '');
                addOutput('overflow-output', 'Exception in thread "main"');
                addOutput('overflow-output', 'java.lang.StackOverflowError');
                btn.textContent = 'Crashed!';
                btn.disabled = true;
                return;
            }

            await delay(200);
            btn.disabled = false;
        }

        function resetOverflowAnimation() {
            overflowCurrentStep = 0;
            const stackEl = document.getElementById('overflow-stack');
            stackEl.innerHTML = '<div class="stack-box-empty">( empty )</div>';
            stackEl.style.borderColor = '#667eea';
            stackEl.style.animation = '';
            document.getElementById('overflow-output').innerHTML = '<div class="output-header">--- Console ---</div>';
            document.getElementById('overflow-error').style.display = 'none';
            setNarration('overflow-narration', 'Press "Run" to start, then click "Next" to see each call fill the stack.');
            setStep('overflow-step', '');
            document.getElementById('overflow-run-btn').style.display = '';
            const nextBtn = document.getElementById('overflow-next-btn');
            nextBtn.style.display = 'none';
            nextBtn.textContent = 'Next';
            nextBtn.disabled = false;
        }
    </script>

</body>
</html>
