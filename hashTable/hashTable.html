<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>From Arrays to Hash Tables - Ahmed and Omar's Journey</title>
    <style>
        :root {
            --primary-color: #2563eb;
            --primary-light: #3b82f6;
            --primary-dark: #1d4ed8;
            --secondary-color: #059669;
            --accent-color: #f59e0b;
            --danger-color: #dc2626;
            --success-color: #16a34a;
            --bg-color: #f8fafc;
            --card-bg: #ffffff;
            --text-color: #1e293b;
            --text-muted: #64748b;
            --border-color: #e2e8f0;
            --code-bg: #1e293b;
            --ahmed-color: #3b82f6;
            --omar-color: #8b5cf6;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            line-height: 1.7;
        }

        /* Header */
        header {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-dark) 100%);
            color: white;
            padding: 3rem 2rem;
            text-align: center;
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        header .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-bottom: 1rem;
        }

        header .authors {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-top: 1.5rem;
        }

        .author-badge {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255,255,255,0.2);
            padding: 0.5rem 1rem;
            border-radius: 50px;
        }

        .author-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2rem;
        }

        .ahmed-avatar { background: var(--ahmed-color); }
        .omar-avatar { background: var(--omar-color); }

        /* Navigation */
        nav {
            background: var(--card-bg);
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 100;
            padding: 1rem;
        }

        nav ul {
            list-style: none;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 0.5rem;
            max-width: 1200px;
            margin: 0 auto;
        }

        nav a {
            text-decoration: none;
            color: var(--text-color);
            padding: 0.5rem 1rem;
            border-radius: 5px;
            transition: all 0.3s;
            font-size: 0.9rem;
        }

        nav a:hover {
            background: var(--primary-color);
            color: white;
        }

        /* Main content */
        main {
            max-width: 1000px;
            margin: 0 auto;
            padding: 2rem;
        }

        /* Abstract */
        .abstract {
            background: linear-gradient(135deg, #e0e7ff 0%, #c7d2fe 100%);
            border-left: 5px solid var(--primary-color);
            padding: 1.5rem;
            border-radius: 0 10px 10px 0;
            margin-bottom: 2rem;
        }

        .abstract h2 {
            color: var(--primary-dark);
            margin-bottom: 1rem;
        }

        /* Sections */
        section {
            background: var(--card-bg);
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            padding: 2rem;
            margin-bottom: 2rem;
        }

        section h2 {
            color: var(--primary-color);
            font-size: 1.8rem;
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid var(--primary-light);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        section h2 .scene-number {
            background: var(--primary-color);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }

        h3 {
            color: var(--secondary-color);
            margin: 1.5rem 0 1rem;
            font-size: 1.3rem;
        }

        h4 {
            color: var(--text-color);
            margin: 1rem 0 0.5rem;
            font-size: 1.1rem;
        }

        /* Dialogue boxes */
        .dialogue {
            margin: 1.5rem 0;
            padding: 1rem 1.5rem;
            border-radius: 15px;
            position: relative;
        }

        .dialogue::before {
            content: '';
            position: absolute;
            left: 20px;
            top: -10px;
            border-width: 10px;
            border-style: solid;
        }

        .dialogue-ahmed {
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
            border-left: 4px solid var(--ahmed-color);
        }

        .dialogue-ahmed::before {
            border-color: transparent transparent #dbeafe transparent;
        }

        .dialogue-omar {
            background: linear-gradient(135deg, #ede9fe 0%, #ddd6fe 100%);
            border-left: 4px solid var(--omar-color);
        }

        .dialogue-omar::before {
            border-color: transparent transparent #ede9fe transparent;
        }

        .dialogue-label {
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .dialogue-ahmed .dialogue-label { color: var(--ahmed-color); }
        .dialogue-omar .dialogue-label { color: var(--omar-color); }

        /* Code blocks */
        .code-block {
            background: var(--code-bg);
            color: #e2e8f0;
            padding: 1.5rem;
            border-radius: 10px;
            overflow-x: auto;
            margin: 1rem 0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.95rem;
            line-height: 1.6;
            white-space: pre;
            tab-size: 4;
        }

        .code-block code {
            display: block;
            white-space: pre;
        }

        .code-block .keyword { color: #c084fc; }
        .code-block .type { color: #38bdf8; }
        .code-block .function { color: #fbbf24; }
        .code-block .string { color: #4ade80; }
        .code-block .comment { color: #94a3b8; font-style: italic; }
        .code-block .number { color: #f472b6; }

        /* Formula boxes */
        .formula-box {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border: 2px solid var(--accent-color);
            border-radius: 10px;
            padding: 1rem 1.5rem;
            margin: 1rem 0;
            text-align: center;
            font-size: 1.2rem;
        }

        .formula-box .formula {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            color: var(--text-color);
        }

        /* Complexity boxes */
        .complexity-box {
            display: inline-block;
            background: linear-gradient(135deg, #fecaca 0%, #fca5a5 100%);
            border: 2px solid var(--danger-color);
            border-radius: 8px;
            padding: 0.5rem 1rem;
            font-weight: bold;
            color: var(--danger-color);
        }

        .complexity-box.good {
            background: linear-gradient(135deg, #bbf7d0 0%, #86efac 100%);
            border-color: var(--success-color);
            color: var(--success-color);
        }

        /* Info boxes */
        .info-box {
            padding: 1rem 1.5rem;
            border-radius: 10px;
            margin: 1rem 0;
        }

        .info-box.warning {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border-left: 4px solid var(--accent-color);
        }

        .info-box.tip {
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
            border-left: 4px solid var(--secondary-color);
        }

        .info-box.important {
            background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
            border-left: 4px solid var(--danger-color);
        }

        .info-box-title {
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        /* Hash tables visualization */
        .hash-table-viz {
            margin: 1.5rem 0;
            overflow-x: auto;
        }

        .hash-table {
            border-collapse: collapse;
            width: 100%;
            margin: 1rem 0;
        }

        .hash-table th {
            background: var(--primary-color);
            color: white;
            padding: 0.75rem;
            text-align: center;
            font-weight: bold;
        }

        .hash-table td {
            border: 2px solid var(--border-color);
            padding: 0.75rem;
            text-align: center;
            background: white;
            transition: all 0.3s;
        }

        .hash-table tr:hover td {
            background: #f1f5f9;
        }

        .hash-table .index-row td {
            background: #e2e8f0;
            font-weight: bold;
            color: var(--text-muted);
        }

        .hash-table .empty-cell {
            color: var(--text-muted);
            font-style: italic;
        }

        .hash-table .filled-cell {
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
            font-weight: bold;
            color: var(--primary-dark);
        }

        .hash-table .collision-cell {
            background: linear-gradient(135deg, #fecaca 0%, #fca5a5 100%);
            color: var(--danger-color);
        }

        .hash-table .probe-cell {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            color: #b45309;
        }

        .hash-table .success-cell {
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
            color: var(--success-color);
        }

        /* Step-by-step tables */
        .step-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
            font-size: 0.95rem;
        }

        .step-table th {
            background: linear-gradient(135deg, var(--secondary-color) 0%, #047857 100%);
            color: white;
            padding: 0.75rem;
            text-align: left;
        }

        .step-table td {
            border: 1px solid var(--border-color);
            padding: 0.75rem;
            vertical-align: top;
        }

        .step-table tr:nth-child(even) {
            background: #f8fafc;
        }

        .step-table .step-number {
            background: var(--secondary-color);
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 0.5rem;
        }

        /* Probing visualization */
        .probing-steps {
            margin: 1.5rem 0;
        }

        .probe-step {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            margin: 0.5rem 0;
            border-radius: 10px;
            background: #f8fafc;
            border-left: 4px solid var(--border-color);
        }

        .probe-step.initial {
            border-left-color: var(--primary-color);
            background: #eff6ff;
        }

        .probe-step.collision {
            border-left-color: var(--danger-color);
            background: #fef2f2;
        }

        .probe-step.success {
            border-left-color: var(--success-color);
            background: #f0fdf4;
        }

        .probe-step-num {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--text-muted);
            min-width: 40px;
        }

        .probe-step-content {
            flex: 1;
        }

        .probe-step-formula {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            background: white;
            padding: 0.25rem 0.5rem;
            border-radius: 5px;
            display: inline-block;
            margin: 0.25rem 0;
        }

        .probe-step-result {
            font-weight: bold;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            display: inline-block;
            font-size: 0.9rem;
        }

        .result-collision {
            background: #fee2e2;
            color: var(--danger-color);
        }

        .result-empty {
            background: #d1fae5;
            color: var(--success-color);
        }

        /* Comparison table */
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
        }

        .comparison-table th {
            background: var(--primary-color);
            color: white;
            padding: 1rem;
            text-align: center;
        }

        .comparison-table td {
            border: 2px solid var(--border-color);
            padding: 1rem;
            vertical-align: top;
        }

        .comparison-table tr:nth-child(even) {
            background: #f8fafc;
        }

        .comparison-table .method-name {
            font-weight: bold;
            color: var(--primary-color);
            font-size: 1.1rem;
        }

        .pros-cons {
            margin-top: 0.5rem;
        }

        .pros-cons .pro {
            color: var(--success-color);
        }

        .pros-cons .con {
            color: var(--danger-color);
        }

        /* Lists */
        ul, ol {
            margin: 1rem 0 1rem 1.5rem;
        }

        li {
            margin: 0.5rem 0;
        }

        /* Key concept highlight */
        .key-concept {
            background: linear-gradient(135deg, #e0e7ff 0%, #c7d2fe 100%);
            border: 2px solid var(--primary-color);
            border-radius: 10px;
            padding: 1.5rem;
            margin: 1.5rem 0;
        }

        .key-concept h4 {
            color: var(--primary-dark);
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Summary cards */
        .summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1rem;
            margin: 1.5rem 0;
        }

        .summary-card {
            background: white;
            border-radius: 10px;
            padding: 1.5rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            border-top: 4px solid var(--primary-color);
        }

        .summary-card h4 {
            color: var(--primary-color);
            margin-bottom: 0.75rem;
        }

        .summary-card.warning-card {
            border-top-color: var(--accent-color);
        }

        .summary-card.success-card {
            border-top-color: var(--success-color);
        }

        /* Footer */
        footer {
            background: var(--code-bg);
            color: white;
            text-align: center;
            padding: 2rem;
            margin-top: 2rem;
        }

        footer p {
            opacity: 0.8;
        }

        /* Responsive */
        @media (max-width: 768px) {
            header h1 {
                font-size: 1.8rem;
            }

            header .authors {
                flex-direction: column;
                gap: 0.5rem;
            }

            nav ul {
                flex-direction: column;
                align-items: center;
            }

            main {
                padding: 1rem;
            }

            section {
                padding: 1.5rem;
            }

            .hash-table {
                font-size: 0.85rem;
            }

            .hash-table th, .hash-table td {
                padding: 0.5rem;
            }
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        section {
            animation: fadeIn 0.5s ease-out;
        }

        /* Print styles */
        @media print {
            nav { display: none; }
            section { box-shadow: none; border: 1px solid #ddd; }
        }
    </style>
</head>
<body>
    <header>
        <a href="index.html" style="color: white; text-decoration: none; opacity: 0.8; font-size: 0.95rem; display: inline-block; margin-bottom: 1rem;">‚Üê Back to Home</a>
        <h1>From Arrays to Hash Tables</h1>
        <p class="subtitle">A Story of Ahmed and Omar Discovering Hashing</p>
        <p>Prepared for Students of Data Structures</p>
        <div class="authors">
            <div class="author-badge">
                <div class="author-avatar ahmed-avatar">A</div>
                <span>Ahmed</span>
            </div>
            <div class="author-badge">
                <div class="author-avatar omar-avatar">O</div>
                <span>Omar</span>
            </div>
        </div>
    </header>

    <nav>
        <ul>
            <li><a href="#scene1">1. Arrays</a></li>
            <li><a href="#scene2">2. Binary Search</a></li>
            <li><a href="#scene3">3. Direct Addressing</a></li>
            <li><a href="#scene4">4. Hashing</a></li>
            <li><a href="#scene5">5. Collisions</a></li>
            <li><a href="#scene6">6. Linear Probing</a></li>
            <li><a href="#scene7">7. Quadratic Probing</a></li>
            <li><a href="#scene8">8. Double Hashing</a></li>
            <li><a href="#scene9">9. Comparison</a></li>
            <li><a href="#conclusion">Conclusion</a></li>
        </ul>
    </nav>

    <main>
        <!-- Abstract -->
        <div class="abstract">
            <h2>About This Tutorial</h2>
            <p>This tutorial tells the story of two students, <strong>Ahmed</strong> and <strong>Omar</strong>, who want to store and search student records efficiently. Starting from simple arrays and linear search, they gradually discover binary search, direct addressing, and finally hash tables with different collision resolution strategies: <strong>linear probing</strong>, <strong>quadratic probing</strong>, and <strong>double hashing</strong>.</p>
        </div>

        <!-- Scene 1 -->
        <section id="scene1">
            <h2><span class="scene-number">1</span> Ahmed's First Idea ‚Äî Just Use an Array</h2>

            <p>Ahmed is implementing a small system to store students. For each student he has a <code>studentID</code>, like 101, 203, 517, and so on, and perhaps a name and a GPA.</p>

            <p>The simplest data structure Ahmed knows is an <em>array</em>. So he writes:</p>

            <div class="code-block"><span class="type">Student</span>[] students = <span class="keyword">new</span> <span class="type">Student</span>[N];  <span class="comment">// N = maximum number of students</span>
<span class="type">int</span> count = <span class="number">0</span>;                          <span class="comment">// how many students are currently stored</span>

<span class="keyword">void</span> <span class="function">insertStudent</span>(<span class="type">Student</span> s) {
    students[count] = s;
    count++;
}</div>

            <p>To <em>search</em> for a particular student by ID, Ahmed loops over the array:</p>

            <div class="code-block"><span class="type">Student</span> <span class="function">findStudent</span>(<span class="type">int</span> id) {
    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) {
        <span class="keyword">if</span> (students[i].id == id) {
            <span class="keyword">return</span> students[i];
        }
    }
    <span class="keyword">return</span> <span class="keyword">null</span>;  <span class="comment">// not found</span>
}</div>

            <h3>Time Complexity of Linear Search</h3>

            <div class="dialogue dialogue-omar">
                <div class="dialogue-label">Omar asks:</div>
                <p>"Ahmed, your search is correct, but how fast is it?"</p>
            </div>

            <div class="dialogue dialogue-ahmed">
                <div class="dialogue-label">Ahmed thinks:</div>
                <ul>
                    <li>In the <em>worst case</em>, the student is not in the array, or is the last one. Then the loop checks all <strong>n</strong> elements.</li>
                    <li>So the worst-case time is proportional to n.</li>
                </ul>
            </div>

            <div class="formula-box">
                <p>Time Complexity:</p>
                <p class="formula"><strong>T(n) = O(n)</strong></p>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">‚ö†Ô∏è Linear Search</div>
                <p>This is called <strong>linear search</strong>. It is simple, but when the number of students is large, it becomes slow.</p>
            </div>
        </section>

        <!-- Scene 2 -->
        <section id="scene2">
            <h2><span class="scene-number">2</span> Omar's Suggestion ‚Äî Sorting and Binary Search</h2>

            <div class="dialogue dialogue-omar">
                <div class="dialogue-label">Omar suggests:</div>
                <p>"Ahmed, what if we <em>sort</em> the array of students by their ID? If the array is sorted, we can use <strong>binary search</strong>. That will be much faster than linear search."</p>
            </div>

            <h3>Binary Search Idea</h3>

            <p>If the array is sorted by <code>studentID</code>, binary search works like this:</p>

            <table class="step-table">
                <tr>
                    <th>Step</th>
                    <th>Action</th>
                </tr>
                <tr>
                    <td><span class="step-number">1</span></td>
                    <td>Look at the <em>middle</em> index</td>
                </tr>
                <tr>
                    <td><span class="step-number">2</span></td>
                    <td>If the middle student has the target ID, we are done</td>
                </tr>
                <tr>
                    <td><span class="step-number">3</span></td>
                    <td>If the target ID is <strong>smaller</strong>, search only in the <strong>left half</strong></td>
                </tr>
                <tr>
                    <td><span class="step-number">4</span></td>
                    <td>If the target ID is <strong>larger</strong>, search only in the <strong>right half</strong></td>
                </tr>
                <tr>
                    <td><span class="step-number">5</span></td>
                    <td>Repeat with the new half</td>
                </tr>
            </table>

            <p>At each step, the search <em>halves</em> the remaining part of the array.</p>

            <div class="formula-box">
                <p>Time Complexity of Binary Search:</p>
                <p class="formula"><strong>T(n) = O(log n)</strong></p>
            </div>

            <div class="dialogue dialogue-ahmed">
                <div class="dialogue-label">Ahmed is happy:</div>
                <p>"Great! I will sort the array once, and then all my searches will be fast!"</p>
            </div>

            <h3>But What About Updates?</h3>

            <div class="dialogue dialogue-omar">
                <div class="dialogue-label">Omar:</div>
                <p>"Ahmed, you are right that binary search is fast, but you forgot something."</p>
            </div>

            <div class="dialogue dialogue-ahmed">
                <div class="dialogue-label">Ahmed:</div>
                <p>"What did I forget?"</p>
            </div>

            <div class="dialogue dialogue-omar">
                <div class="dialogue-label">Omar:</div>
                <p>"What happens when a <em>new student</em> arrives? If you just append it at the end, the array will no longer be sorted, and binary search will not work."</p>
            </div>

            <h3>Trade-off Comparison</h3>

            <table class="comparison-table">
                <tr>
                    <th>Approach</th>
                    <th>Insert Time</th>
                    <th>Search Time</th>
                </tr>
                <tr>
                    <td class="method-name">Unsorted Array + Linear Search</td>
                    <td><span class="complexity-box good">O(1)</span><br><small>(append at end)</small></td>
                    <td><span class="complexity-box">O(n)</span></td>
                </tr>
                <tr>
                    <td class="method-name">Sorted Array + Binary Search</td>
                    <td><span class="complexity-box">O(n)</span><br><small>(to keep things sorted)</small></td>
                    <td><span class="complexity-box good">O(log n)</span></td>
                </tr>
            </table>

            <div class="key-concept">
                <h4>ü§î The Big Question</h4>
                <p><strong>Can we get both <em>fast search</em> AND <em>fast insert</em> at the same time?</strong></p>
                <p>This question leads Ahmed and Omar to <strong>hashing</strong>!</p>
            </div>
        </section>

        <!-- Scene 3 -->
        <section id="scene3">
            <h2><span class="scene-number">3</span> Omar's Wild Idea ‚Äî A Huge Direct-Access Array</h2>

            <div class="dialogue dialogue-omar">
                <div class="dialogue-label">Omar proposes:</div>
                <p>"Suppose the student IDs are guaranteed to be between 1 and 100. Why don't we create an array of size 100, where index <em>i</em> directly holds the student with ID <em>i</em>? Then search is <em>instant</em>."</p>
            </div>

            <p>This is called a <strong>direct-address table</strong>.</p>

            <h3>Direct Addressing Example</h3>

            <div class="code-block"><span class="type">Student</span>[] table = <span class="keyword">new</span> <span class="type">Student</span>[<span class="number">101</span>];  <span class="comment">// ignore index 0, use 1..100</span>

<span class="keyword">void</span> <span class="function">insert</span>(<span class="type">Student</span> s) {
    table[s.id] = s;  <span class="comment">// direct mapping</span>
}

<span class="type">Student</span> <span class="function">find</span>(<span class="type">int</span> id) {
    <span class="keyword">return</span> table[id];  <span class="comment">// O(1) lookup</span>
}</div>

            <div class="formula-box">
                <p>Search Time:</p>
                <p class="formula"><strong>O(1)</strong> ‚Äî Just one array access!</p>
            </div>

            <h3>But There is a Big Problem: Memory</h3>

            <div class="dialogue dialogue-ahmed">
                <div class="dialogue-label">Ahmed sees a problem:</div>
                <p>"But Omar, what if we only have 5 students, and their IDs are 3, 7, 42, 50, 99? We still allocate an array of size 100 and use only 5 cells. This is a huge waste of memory."</p>
            </div>

            <div class="info-box important">
                <div class="info-box-title">‚ö†Ô∏è Memory Problem</div>
                <p>Direct addressing is only good if the key range is <strong>small and dense</strong>. For large, sparse key ranges, it wastes enormous amounts of memory.</p>
            </div>
        </section>

        <!-- Scene 4 -->
        <section id="scene4">
            <h2><span class="scene-number">4</span> The Birth of Hashing</h2>

            <div class="dialogue dialogue-omar">
                <div class="dialogue-label">Omar proposes:</div>
                <p>"Why don't we keep a small array, with size, say, 10 or 11, but still try to find a clever way to map any student ID into one of these positions?"</p>
            </div>

            <div class="dialogue dialogue-ahmed">
                <div class="dialogue-label">Ahmed:</div>
                <p>"So we need a function that takes the key (the student ID) and returns an index of the array."</p>
            </div>

            <div class="dialogue dialogue-omar">
                <div class="dialogue-label">Omar:</div>
                <p>"Exactly. That function is called a <em>hash function</em>."</p>
            </div>

            <div class="key-concept">
                <h4>üìñ Hash Function Definition</h4>
                <p>Let <strong>m</strong> be the size of the array (also called the <em>hash table</em> size). A hash function is:</p>
                <div class="formula-box">
                    <p class="formula"><strong>h(k) ‚àà {0, 1, 2, ..., m-1}</strong></p>
                </div>
                <p>that maps a key <strong>k</strong> (like a student ID) to a valid index in the table.</p>
            </div>

            <h3>Using Modulo to Keep Indices in Range</h3>

            <div class="dialogue dialogue-omar">
                <div class="dialogue-label">Omar remembers:</div>
                <p>"One of the most fantastic operations in computer science is <em>modulo</em>. If we take any integer k and compute <strong>k mod m</strong>, the result is always between 0 and m-1."</p>
            </div>

            <div class="formula-box">
                <p>Common Hash Function:</p>
                <p class="formula"><strong>h(k) = k mod m</strong></p>
            </div>

            <h3>Example: Hash Function with m = 10</h3>

            <table class="hash-table">
                <tr>
                    <th>Key (k)</th>
                    <th>Calculation</th>
                    <th>h(k) = k mod 10</th>
                </tr>
                <tr>
                    <td>27</td>
                    <td>27 mod 10</td>
                    <td class="filled-cell">7</td>
                </tr>
                <tr>
                    <td>40</td>
                    <td>40 mod 10</td>
                    <td class="filled-cell">0</td>
                </tr>
                <tr>
                    <td>55</td>
                    <td>55 mod 10</td>
                    <td class="filled-cell">5</td>
                </tr>
                <tr>
                    <td>66</td>
                    <td>66 mod 10</td>
                    <td class="filled-cell">6</td>
                </tr>
                <tr>
                    <td>80</td>
                    <td>80 mod 10</td>
                    <td class="collision-cell">0 ‚ö†Ô∏è</td>
                </tr>
            </table>

            <div class="info-box warning">
                <div class="info-box-title">‚ö†Ô∏è Notice Something?</div>
                <p>Both <strong>40</strong> and <strong>80</strong> hash to index <strong>0</strong>! This is called a <strong>collision</strong>.</p>
            </div>
        </section>

        <!-- Scene 5 -->
        <section id="scene5">
            <h2><span class="scene-number">5</span> The Collision Problem</h2>

            <p>Ahmed implements the hash table with m = 10 and hash function h(k) = k mod 10. He tries to insert student IDs: 40, 55, 66, and 80.</p>

            <table class="hash-table">
                <tr>
                    <th>Key (k)</th>
                    <th>h(k) = k mod 10</th>
                    <th>Status</th>
                </tr>
                <tr>
                    <td>40</td>
                    <td class="filled-cell">0</td>
                    <td>‚úÖ Stored at index 0</td>
                </tr>
                <tr>
                    <td>55</td>
                    <td class="filled-cell">5</td>
                    <td>‚úÖ Stored at index 5</td>
                </tr>
                <tr>
                    <td>66</td>
                    <td class="filled-cell">6</td>
                    <td>‚úÖ Stored at index 6</td>
                </tr>
                <tr>
                    <td>80</td>
                    <td class="collision-cell">0</td>
                    <td>‚ùå Index 0 is occupied by 40!</td>
                </tr>
            </table>

            <div class="dialogue dialogue-ahmed">
                <div class="dialogue-label">Ahmed:</div>
                <p>"Oh no! 80 also hashes to 0, but index 0 is already occupied by 40. We have a <em>collision</em>."</p>
            </div>

            <div class="key-concept">
                <h4>üîë What is a Collision?</h4>
                <p>A collision happens when two different keys k‚ÇÅ ‚â† k‚ÇÇ produce the same hash value:</p>
                <div class="formula-box">
                    <p class="formula"><strong>h(k‚ÇÅ) = h(k‚ÇÇ)</strong></p>
                </div>
                <p>Collisions are <strong>unavoidable</strong> when we map a large key space into a smaller table. This follows from the <em>pigeonhole principle</em>: if more pigeons (keys) than holes (table slots) exist, at least one hole must contain more than one pigeon.</p>
            </div>

            <h3>Collision Resolution Strategies</h3>

            <p>So a hash table needs a strategy to <em>resolve</em> collisions. In this tutorial we focus on <strong>open addressing</strong> methods:</p>

            <div class="summary-cards">
                <div class="summary-card">
                    <h4>1. Linear Probing</h4>
                    <p>Try the next slot, then the next, and so on...</p>
                </div>
                <div class="summary-card">
                    <h4>2. Quadratic Probing</h4>
                    <p>Try slots at increasing square distances...</p>
                </div>
                <div class="summary-card">
                    <h4>3. Double Hashing</h4>
                    <p>Use a second hash function for step size...</p>
                </div>
            </div>
        </section>

        <!-- Scene 6: Linear Probing -->
        <section id="scene6">
            <h2><span class="scene-number">6</span> Linear Probing</h2>

            <div class="dialogue dialogue-omar">
                <div class="dialogue-label">Omar suggests:</div>
                <p>"If the desired position h(k) is already occupied, try the next cells in a linear manner until you find an empty slot."</p>
            </div>

            <div class="key-concept">
                <h4>üìñ Linear Probing Formula</h4>
                <p>The probe sequence (the sequence of indices we try) is:</p>
                <div class="formula-box">
                    <p class="formula"><strong>index<sub>i</sub> = (h(k) + i) mod m</strong></p>
                    <p><small>where i = 0, 1, 2, 3, ...</small></p>
                </div>
                <p>So we try: h(k), h(k)+1, h(k)+2, h(k)+3, ... (all taken modulo m)</p>
            </div>

            <h3>Example: Linear Probing Step-by-Step</h3>

            <p><strong>Settings:</strong> m = 10, h(k) = k mod 10</p>
            <p><strong>Insert keys:</strong> 40, 55, 66, 80, 90</p>

            <!-- Insert 40 -->
            <h4>Step 1: Insert 40</h4>
            <div class="probing-steps">
                <div class="probe-step success">
                    <div class="probe-step-num">i=0</div>
                    <div class="probe-step-content">
                        <div class="probe-step-formula">h(40) = 40 mod 10 = <strong>0</strong></div>
                        <br><span class="probe-step-result result-empty">‚úÖ Index 0 is empty ‚Üí Store 40 here</span>
                    </div>
                </div>
            </div>

            <!-- Insert 55 -->
            <h4>Step 2: Insert 55</h4>
            <div class="probing-steps">
                <div class="probe-step success">
                    <div class="probe-step-num">i=0</div>
                    <div class="probe-step-content">
                        <div class="probe-step-formula">h(55) = 55 mod 10 = <strong>5</strong></div>
                        <br><span class="probe-step-result result-empty">‚úÖ Index 5 is empty ‚Üí Store 55 here</span>
                    </div>
                </div>
            </div>

            <!-- Insert 66 -->
            <h4>Step 3: Insert 66</h4>
            <div class="probing-steps">
                <div class="probe-step success">
                    <div class="probe-step-num">i=0</div>
                    <div class="probe-step-content">
                        <div class="probe-step-formula">h(66) = 66 mod 10 = <strong>6</strong></div>
                        <br><span class="probe-step-result result-empty">‚úÖ Index 6 is empty ‚Üí Store 66 here</span>
                    </div>
                </div>
            </div>

            <!-- Insert 80 -->
            <h4>Step 4: Insert 80 (COLLISION!)</h4>
            <div class="probing-steps">
                <div class="probe-step collision">
                    <div class="probe-step-num">i=0</div>
                    <div class="probe-step-content">
                        <div class="probe-step-formula">h(80) = 80 mod 10 = <strong>0</strong></div>
                        <br><span class="probe-step-result result-collision">‚ùå Index 0 is occupied (40) ‚Üí Try next</span>
                    </div>
                </div>
                <div class="probe-step success">
                    <div class="probe-step-num">i=1</div>
                    <div class="probe-step-content">
                        <div class="probe-step-formula">(0 + 1) mod 10 = <strong>1</strong></div>
                        <br><span class="probe-step-result result-empty">‚úÖ Index 1 is empty ‚Üí Store 80 here</span>
                    </div>
                </div>
            </div>

            <!-- Insert 90 -->
            <h4>Step 5: Insert 90 (COLLISION!)</h4>
            <div class="probing-steps">
                <div class="probe-step collision">
                    <div class="probe-step-num">i=0</div>
                    <div class="probe-step-content">
                        <div class="probe-step-formula">h(90) = 90 mod 10 = <strong>0</strong></div>
                        <br><span class="probe-step-result result-collision">‚ùå Index 0 is occupied (40) ‚Üí Try next</span>
                    </div>
                </div>
                <div class="probe-step collision">
                    <div class="probe-step-num">i=1</div>
                    <div class="probe-step-content">
                        <div class="probe-step-formula">(0 + 1) mod 10 = <strong>1</strong></div>
                        <br><span class="probe-step-result result-collision">‚ùå Index 1 is occupied (80) ‚Üí Try next</span>
                    </div>
                </div>
                <div class="probe-step success">
                    <div class="probe-step-num">i=2</div>
                    <div class="probe-step-content">
                        <div class="probe-step-formula">(0 + 2) mod 10 = <strong>2</strong></div>
                        <br><span class="probe-step-result result-empty">‚úÖ Index 2 is empty ‚Üí Store 90 here</span>
                    </div>
                </div>
            </div>

            <h3>Final Hash Table State</h3>

            <div class="hash-table-viz">
                <table class="hash-table">
                    <tr class="index-row">
                        <td>Index</td>
                        <td>0</td>
                        <td>1</td>
                        <td>2</td>
                        <td>3</td>
                        <td>4</td>
                        <td>5</td>
                        <td>6</td>
                        <td>7</td>
                        <td>8</td>
                        <td>9</td>
                    </tr>
                    <tr>
                        <td><strong>Key</strong></td>
                        <td class="filled-cell">40</td>
                        <td class="probe-cell">80</td>
                        <td class="probe-cell">90</td>
                        <td class="empty-cell">‚Äî</td>
                        <td class="empty-cell">‚Äî</td>
                        <td class="filled-cell">55</td>
                        <td class="filled-cell">66</td>
                        <td class="empty-cell">‚Äî</td>
                        <td class="empty-cell">‚Äî</td>
                        <td class="empty-cell">‚Äî</td>
                    </tr>
                </table>
                <p style="text-align: center; color: var(--text-muted); font-size: 0.9rem;">
                    <span style="display: inline-block; width: 20px; height: 15px; background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%); vertical-align: middle; margin-right: 5px;"></span> Direct placement
                    <span style="display: inline-block; width: 20px; height: 15px; background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); vertical-align: middle; margin-left: 15px; margin-right: 5px;"></span> Placed after probing (collision resolved)
                </p>
            </div>

            <h3>Searching with Linear Probing</h3>

            <table class="step-table">
                <tr>
                    <th>Step</th>
                    <th>Action</th>
                </tr>
                <tr>
                    <td><span class="step-number">1</span></td>
                    <td>Compute h(k)</td>
                </tr>
                <tr>
                    <td><span class="step-number">2</span></td>
                    <td>If table[h(k)] holds k ‚Üí <strong>Found!</strong></td>
                </tr>
                <tr>
                    <td><span class="step-number">3</span></td>
                    <td>Otherwise, check table[h(k)+1], then table[h(k)+2], ... (wrapping with modulo)</td>
                </tr>
                <tr>
                    <td><span class="step-number">4</span></td>
                    <td>Stop when: you find the key ‚Üí <strong>Success</strong>, OR you hit an empty slot ‚Üí <strong>Not found</strong></td>
                </tr>
            </table>

            <h3>Primary Clustering Problem</h3>

            <div class="dialogue dialogue-omar">
                <div class="dialogue-label">Omar points out:</div>
                <p>"Look at indices 0, 1, and 2. They contain 40, 80, and 90. They form a big <em>cluster</em> of consecutive filled cells. Any new key that hashes to index 0, 1, or 2 will have to step through this cluster."</p>
            </div>

            <div class="info-box important">
                <div class="info-box-title">‚ö†Ô∏è Primary Clustering</div>
                <p>Large clusters make insert and search slower because many keys have to probe through the same long block of occupied cells.</p>
                <p><strong>Linear probing is simple, but clustering can be bad when the table becomes moderately full.</strong></p>
            </div>
        </section>

        <!-- Scene 7: Quadratic Probing -->
        <section id="scene7">
            <h2><span class="scene-number">7</span> Quadratic Probing</h2>

            <p>To reduce clustering, Ahmed reads about <strong>quadratic probing</strong>.</p>

            <div class="key-concept">
                <h4>üìñ Quadratic Probing Formula</h4>
                <p>Instead of probing linearly at offsets 0, 1, 2, 3, ..., quadratic probing uses increasing <strong>square</strong> distances:</p>
                <div class="formula-box">
                    <p class="formula"><strong>index<sub>i</sub> = (h(k) + i¬≤) mod m</strong></p>
                    <p><small>where i = 0, 1, 2, 3, ...</small></p>
                </div>
                <p>So the probe offsets are: <strong>0, 1, 4, 9, 16, 25, ...</strong></p>
            </div>

            <h3>Example: Quadratic Probing Step-by-Step</h3>

            <p><strong>Settings:</strong> m = 11, h(k) = k mod 11</p>
            <p><strong>Insert keys:</strong> 5, 16, 27</p>

            <!-- Insert 5 -->
            <h4>Step 1: Insert 5</h4>
            <div class="probing-steps">
                <div class="probe-step success">
                    <div class="probe-step-num">i=0</div>
                    <div class="probe-step-content">
                        <div class="probe-step-formula">h(5) = 5 mod 11 = <strong>5</strong></div>
                        <div class="probe-step-formula">index‚ÇÄ = (5 + 0¬≤) mod 11 = <strong>5</strong></div>
                        <br><span class="probe-step-result result-empty">‚úÖ Index 5 is empty ‚Üí Store 5 here</span>
                    </div>
                </div>
            </div>

            <!-- Insert 16 -->
            <h4>Step 2: Insert 16 (COLLISION!)</h4>
            <div class="probing-steps">
                <div class="probe-step collision">
                    <div class="probe-step-num">i=0</div>
                    <div class="probe-step-content">
                        <div class="probe-step-formula">h(16) = 16 mod 11 = <strong>5</strong></div>
                        <div class="probe-step-formula">index‚ÇÄ = (5 + 0¬≤) mod 11 = <strong>5</strong></div>
                        <br><span class="probe-step-result result-collision">‚ùå Index 5 is occupied (5) ‚Üí Try next</span>
                    </div>
                </div>
                <div class="probe-step success">
                    <div class="probe-step-num">i=1</div>
                    <div class="probe-step-content">
                        <div class="probe-step-formula">index‚ÇÅ = (5 + 1¬≤) mod 11 = (5 + 1) mod 11 = <strong>6</strong></div>
                        <br><span class="probe-step-result result-empty">‚úÖ Index 6 is empty ‚Üí Store 16 here</span>
                    </div>
                </div>
            </div>

            <!-- Insert 27 -->
            <h4>Step 3: Insert 27 (COLLISION!)</h4>
            <div class="probing-steps">
                <div class="probe-step collision">
                    <div class="probe-step-num">i=0</div>
                    <div class="probe-step-content">
                        <div class="probe-step-formula">h(27) = 27 mod 11 = <strong>5</strong></div>
                        <div class="probe-step-formula">index‚ÇÄ = (5 + 0¬≤) mod 11 = <strong>5</strong></div>
                        <br><span class="probe-step-result result-collision">‚ùå Index 5 is occupied (5) ‚Üí Try next</span>
                    </div>
                </div>
                <div class="probe-step collision">
                    <div class="probe-step-num">i=1</div>
                    <div class="probe-step-content">
                        <div class="probe-step-formula">index‚ÇÅ = (5 + 1¬≤) mod 11 = (5 + 1) mod 11 = <strong>6</strong></div>
                        <br><span class="probe-step-result result-collision">‚ùå Index 6 is occupied (16) ‚Üí Try next</span>
                    </div>
                </div>
                <div class="probe-step success">
                    <div class="probe-step-num">i=2</div>
                    <div class="probe-step-content">
                        <div class="probe-step-formula">index‚ÇÇ = (5 + 2¬≤) mod 11 = (5 + 4) mod 11 = <strong>9</strong></div>
                        <br><span class="probe-step-result result-empty">‚úÖ Index 9 is empty ‚Üí Store 27 here</span>
                    </div>
                </div>
            </div>

            <h3>Final Hash Table State</h3>

            <div class="hash-table-viz">
                <table class="hash-table">
                    <tr class="index-row">
                        <td>Index</td>
                        <td>0</td>
                        <td>1</td>
                        <td>2</td>
                        <td>3</td>
                        <td>4</td>
                        <td>5</td>
                        <td>6</td>
                        <td>7</td>
                        <td>8</td>
                        <td>9</td>
                        <td>10</td>
                    </tr>
                    <tr>
                        <td><strong>Key</strong></td>
                        <td class="empty-cell">‚Äî</td>
                        <td class="empty-cell">‚Äî</td>
                        <td class="empty-cell">‚Äî</td>
                        <td class="empty-cell">‚Äî</td>
                        <td class="empty-cell">‚Äî</td>
                        <td class="filled-cell">5</td>
                        <td class="probe-cell">16</td>
                        <td class="empty-cell">‚Äî</td>
                        <td class="empty-cell">‚Äî</td>
                        <td class="probe-cell">27</td>
                        <td class="empty-cell">‚Äî</td>
                    </tr>
                </table>
            </div>

            <div class="info-box tip">
                <div class="info-box-title">‚úÖ Advantage</div>
                <p>Keys with the same hash value (5, 16, 27 all hash to 5) do <strong>not</strong> form one long consecutive block as in linear probing. They are spread out: positions 5, 6, 9, ... This helps <strong>reduce primary clustering</strong>.</p>
            </div>

            <h3>The Problem: Some Slots May Never Be Visited</h3>

            <div class="info-box warning">
                <div class="info-box-title">‚ö†Ô∏è Limitation of Quadratic Probing</div>
                <p>The sequence of probes for one key uses indices: (h(k) + i¬≤) mod m</p>
                <p>Mathematically, the set of values i¬≤ mod m might <strong>not cover all</strong> residues from 0 to m-1.</p>
                <ul>
                    <li>With careful choice of table size m (often prime), we can guarantee visiting about <strong>(m+1)/2</strong> distinct positions.</li>
                    <li>So if the table is less than half full, we can always find an empty slot.</li>
                    <li>But we do <strong>not necessarily visit every position</strong>.</li>
                </ul>
            </div>
        </section>

        <!-- Scene 8: Double Hashing -->
        <section id="scene8">
            <h2><span class="scene-number">8</span> Double Hashing</h2>

            <div class="dialogue dialogue-omar">
                <div class="dialogue-label">Omar suggests:</div>
                <p>"Let me suggest a more powerful idea: <strong>double hashing</strong>. We use <em>two</em> hash functions!"</p>
            </div>

            <div class="key-concept">
                <h4>üìñ Double Hashing Formula</h4>
                <p>We use <strong>two</strong> hash functions: h‚ÇÅ(k) and h‚ÇÇ(k)</p>
                <div class="formula-box">
                    <p class="formula"><strong>index<sub>i</sub> = (h‚ÇÅ(k) + i √ó h‚ÇÇ(k)) mod m</strong></p>
                    <p><small>where i = 0, 1, 2, ...</small></p>
                </div>
                <ul>
                    <li><strong>h‚ÇÅ(k)</strong> gives the <em>initial position</em></li>
                    <li><strong>h‚ÇÇ(k)</strong> gives the <em>step size</em> for probing</li>
                </ul>
            </div>

            <h3>Why h‚ÇÇ(k) Must Not Be Zero</h3>

            <div class="dialogue dialogue-ahmed">
                <div class="dialogue-label">Ahmed asks:</div>
                <p>"Why must the second hash function never return 0?"</p>
            </div>

            <div class="dialogue dialogue-omar">
                <div class="dialogue-label">Omar explains:</div>
                <p>"Look at the probe formula: index<sub>i</sub> = (h‚ÇÅ(k) + i √ó h‚ÇÇ(k)) mod m</p>
                <p>If h‚ÇÇ(k) = 0, then for all i:</p>
                <p style="text-align: center;"><strong>index<sub>i</sub> = (h‚ÇÅ(k) + i √ó 0) mod m = h‚ÇÅ(k)</strong></p>
                <p>We would keep probing the same index again and again, never moving to another slot!"</p>
            </div>

            <h3>Why h‚ÇÇ(k) Should Be Relatively Prime to m</h3>

            <div class="info-box tip">
                <div class="info-box-title">üìê Mathematical Requirement</div>
                <p>For the probe sequence to <strong>visit ALL positions</strong> of the table before repeating, the step size h‚ÇÇ(k) must be <strong>relatively prime</strong> to the table size m.</p>
                <p>Two numbers a and m are relatively prime if their greatest common divisor is 1: <strong>gcd(a, m) = 1</strong></p>
            </div>

            <h3>Choosing a Prime Table Size</h3>

            <div class="summary-cards">
                <div class="summary-card success-card">
                    <h4>‚úÖ Easy Solution</h4>
                    <p>Choose <strong>m to be a prime number</strong>!</p>
                    <p>If m is prime, then every integer from 1 to m-1 is relatively prime to m.</p>
                </div>
                <div class="summary-card">
                    <h4>Common h‚ÇÇ(k) Choice</h4>
                    <p><strong>h‚ÇÇ(k) = 1 + (k mod (m-1))</strong></p>
                    <p>This ensures h‚ÇÇ(k) is always in {1, 2, ..., m-1} and never zero.</p>
                </div>
            </div>

            <h3>Example: Double Hashing Step-by-Step</h3>

            <p><strong>Settings:</strong></p>
            <ul>
                <li>Table size: <strong>m = 11</strong> (prime)</li>
                <li><strong>h‚ÇÅ(k) = k mod 11</strong></li>
                <li><strong>h‚ÇÇ(k) = 1 + (k mod 10)</strong></li>
            </ul>
            <p><strong>Insert keys:</strong> 27, 38, 49</p>

            <!-- Insert 27 -->
            <h4>Step 1: Insert 27</h4>

            <table class="step-table">
                <tr>
                    <th colspan="2">Calculate Hash Values for key = 27</th>
                </tr>
                <tr>
                    <td><strong>h‚ÇÅ(27)</strong></td>
                    <td>27 mod 11 = <strong>5</strong></td>
                </tr>
                <tr>
                    <td><strong>h‚ÇÇ(27)</strong></td>
                    <td>1 + (27 mod 10) = 1 + 7 = <strong>8</strong></td>
                </tr>
            </table>

            <div class="probing-steps">
                <div class="probe-step success">
                    <div class="probe-step-num">i=0</div>
                    <div class="probe-step-content">
                        <div class="probe-step-formula">index‚ÇÄ = (5 + 0 √ó 8) mod 11 = <strong>5</strong></div>
                        <br><span class="probe-step-result result-empty">‚úÖ Index 5 is empty ‚Üí Store 27 here</span>
                    </div>
                </div>
            </div>

            <!-- Insert 38 -->
            <h4>Step 2: Insert 38 (COLLISION!)</h4>

            <table class="step-table">
                <tr>
                    <th colspan="2">Calculate Hash Values for key = 38</th>
                </tr>
                <tr>
                    <td><strong>h‚ÇÅ(38)</strong></td>
                    <td>38 mod 11 = <strong>5</strong></td>
                </tr>
                <tr>
                    <td><strong>h‚ÇÇ(38)</strong></td>
                    <td>1 + (38 mod 10) = 1 + 8 = <strong>9</strong></td>
                </tr>
            </table>

            <div class="probing-steps">
                <div class="probe-step collision">
                    <div class="probe-step-num">i=0</div>
                    <div class="probe-step-content">
                        <div class="probe-step-formula">index‚ÇÄ = (5 + 0 √ó 9) mod 11 = <strong>5</strong></div>
                        <br><span class="probe-step-result result-collision">‚ùå Index 5 is occupied (27) ‚Üí Try next</span>
                    </div>
                </div>
                <div class="probe-step success">
                    <div class="probe-step-num">i=1</div>
                    <div class="probe-step-content">
                        <div class="probe-step-formula">index‚ÇÅ = (5 + 1 √ó 9) mod 11 = 14 mod 11 = <strong>3</strong></div>
                        <br><span class="probe-step-result result-empty">‚úÖ Index 3 is empty ‚Üí Store 38 here</span>
                    </div>
                </div>
            </div>

            <!-- Insert 49 -->
            <h4>Step 3: Insert 49 (COLLISION!)</h4>

            <table class="step-table">
                <tr>
                    <th colspan="2">Calculate Hash Values for key = 49</th>
                </tr>
                <tr>
                    <td><strong>h‚ÇÅ(49)</strong></td>
                    <td>49 mod 11 = <strong>5</strong></td>
                </tr>
                <tr>
                    <td><strong>h‚ÇÇ(49)</strong></td>
                    <td>1 + (49 mod 10) = 1 + 9 = <strong>10</strong></td>
                </tr>
            </table>

            <div class="probing-steps">
                <div class="probe-step collision">
                    <div class="probe-step-num">i=0</div>
                    <div class="probe-step-content">
                        <div class="probe-step-formula">index‚ÇÄ = (5 + 0 √ó 10) mod 11 = <strong>5</strong></div>
                        <br><span class="probe-step-result result-collision">‚ùå Index 5 is occupied (27) ‚Üí Try next</span>
                    </div>
                </div>
                <div class="probe-step success">
                    <div class="probe-step-num">i=1</div>
                    <div class="probe-step-content">
                        <div class="probe-step-formula">index‚ÇÅ = (5 + 1 √ó 10) mod 11 = 15 mod 11 = <strong>4</strong></div>
                        <br><span class="probe-step-result result-empty">‚úÖ Index 4 is empty ‚Üí Store 49 here</span>
                    </div>
                </div>
            </div>

            <h3>Final Hash Table State</h3>

            <div class="hash-table-viz">
                <table class="hash-table">
                    <tr class="index-row">
                        <td>Index</td>
                        <td>0</td>
                        <td>1</td>
                        <td>2</td>
                        <td>3</td>
                        <td>4</td>
                        <td>5</td>
                        <td>6</td>
                        <td>7</td>
                        <td>8</td>
                        <td>9</td>
                        <td>10</td>
                    </tr>
                    <tr>
                        <td><strong>Key</strong></td>
                        <td class="empty-cell">‚Äî</td>
                        <td class="empty-cell">‚Äî</td>
                        <td class="empty-cell">‚Äî</td>
                        <td class="probe-cell">38</td>
                        <td class="probe-cell">49</td>
                        <td class="filled-cell">27</td>
                        <td class="empty-cell">‚Äî</td>
                        <td class="empty-cell">‚Äî</td>
                        <td class="empty-cell">‚Äî</td>
                        <td class="empty-cell">‚Äî</td>
                        <td class="empty-cell">‚Äî</td>
                    </tr>
                </table>
            </div>

            <div class="info-box tip">
                <div class="info-box-title">‚úÖ Key Insight</div>
                <p>Even though <strong>h‚ÇÅ(k) is the same</strong> for all three keys (27, 38, 49 all hash to 5), their <strong>h‚ÇÇ(k) values are different</strong> (8, 9, 10), so their <strong>probe sequences are different</strong>!</p>
                <p>This reduces clustering and allows us to explore the table more uniformly.</p>
            </div>

            <h3>Summary: Why h‚ÇÇ(k) Values Differ</h3>

            <table class="comparison-table">
                <tr>
                    <th>Key</th>
                    <th>h‚ÇÅ(k) = k mod 11</th>
                    <th>h‚ÇÇ(k) = 1 + (k mod 10)</th>
                    <th>Final Position</th>
                </tr>
                <tr>
                    <td><strong>27</strong></td>
                    <td>5</td>
                    <td>8</td>
                    <td class="filled-cell">Index 5</td>
                </tr>
                <tr>
                    <td><strong>38</strong></td>
                    <td>5</td>
                    <td>9</td>
                    <td class="probe-cell">Index 3</td>
                </tr>
                <tr>
                    <td><strong>49</strong></td>
                    <td>5</td>
                    <td>10</td>
                    <td class="probe-cell">Index 4</td>
                </tr>
            </table>
        </section>

        <!-- Scene 9: Comparison -->
        <section id="scene9">
            <h2><span class="scene-number">9</span> Comparing the Methods</h2>

            <p>Ahmed and Omar now summarize what they have learned.</p>

            <table class="comparison-table">
                <tr>
                    <th>Method</th>
                    <th>Probe Sequence</th>
                    <th>Pros</th>
                    <th>Cons</th>
                </tr>
                <tr>
                    <td class="method-name">Linear Probing</td>
                    <td>
                        <div class="formula-box" style="margin: 0; padding: 0.5rem;">
                            (h(k) + i) mod m
                        </div>
                    </td>
                    <td>
                        <div class="pros-cons">
                            <span class="pro">‚úì Simple to implement</span><br>
                            <span class="pro">‚úì Fast</span><br>
                            <span class="pro">‚úì Good cache performance</span>
                        </div>
                    </td>
                    <td>
                        <div class="pros-cons">
                            <span class="con">‚úó Primary clustering</span><br>
                            <span class="con">‚úó Long clusters slow down operations</span>
                        </div>
                    </td>
                </tr>
                <tr>
                    <td class="method-name">Quadratic Probing</td>
                    <td>
                        <div class="formula-box" style="margin: 0; padding: 0.5rem;">
                            (h(k) + i¬≤) mod m
                        </div>
                    </td>
                    <td>
                        <div class="pros-cons">
                            <span class="pro">‚úì Reduces primary clustering</span><br>
                            <span class="pro">‚úì Better distribution</span>
                        </div>
                    </td>
                    <td>
                        <div class="pros-cons">
                            <span class="con">‚úó May not visit all positions</span><br>
                            <span class="con">‚úó Table should be less than half full</span><br>
                            <span class="con">‚úó Secondary clustering possible</span>
                        </div>
                    </td>
                </tr>
                <tr>
                    <td class="method-name">Double Hashing</td>
                    <td>
                        <div class="formula-box" style="margin: 0; padding: 0.5rem;">
                            (h‚ÇÅ(k) + i √ó h‚ÇÇ(k)) mod m
                        </div>
                    </td>
                    <td>
                        <div class="pros-cons">
                            <span class="pro">‚úì Minimal clustering</span><br>
                            <span class="pro">‚úì Can visit ALL positions</span><br>
                            <span class="pro">‚úì Best distribution</span>
                        </div>
                    </td>
                    <td>
                        <div class="pros-cons">
                            <span class="con">‚úó More complex</span><br>
                            <span class="con">‚úó Needs two hash functions</span><br>
                            <span class="con">‚úó h‚ÇÇ(k) must be coprime with m</span>
                        </div>
                    </td>
                </tr>
            </table>

            <h3>Requirements for Double Hashing</h3>

            <div class="summary-cards">
                <div class="summary-card warning-card">
                    <h4>‚ö†Ô∏è h‚ÇÇ(k) ‚â† 0</h4>
                    <p>The second hash function must <strong>never return 0</strong>, or we'll keep probing the same position forever.</p>
                </div>
                <div class="summary-card">
                    <h4>üìê gcd(h‚ÇÇ(k), m) = 1</h4>
                    <p>h‚ÇÇ(k) must be <strong>relatively prime to m</strong> to ensure all positions can be visited.</p>
                </div>
                <div class="summary-card success-card">
                    <h4>‚úÖ Use Prime m</h4>
                    <p>Choosing a <strong>prime table size</strong> makes it easy to satisfy the coprimality requirement.</p>
                </div>
            </div>
        </section>

        <!-- Scene 10: Final Conversation -->
        <section id="scene10">
            <h2><span class="scene-number">10</span> The Final Conversation</h2>

            <div class="dialogue dialogue-ahmed">
                <div class="dialogue-label">Ahmed reflects:</div>
                <p>"We started with a simple array and linear search: correct but O(n). Then we used sorting and binary search to get O(log n) search but expensive insertions."</p>
            </div>

            <div class="dialogue dialogue-omar">
                <div class="dialogue-label">Omar adds:</div>
                <p>"We tried direct addressing, which gives O(1) search, but wastes a lot of memory if the key range is large."</p>
            </div>

            <div class="dialogue dialogue-ahmed">
                <div class="dialogue-label">Ahmed:</div>
                <p>"Then we discovered hash tables: a clever way to map keys to a smaller array using a hash function."</p>
            </div>

            <div class="dialogue dialogue-omar">
                <div class="dialogue-label">Omar:</div>
                <p>"But hashing is not perfect: collisions are inevitable. We studied three open-addressing methods to handle collisions: linear probing, quadratic probing, and double hashing."</p>
            </div>

            <div class="dialogue dialogue-ahmed">
                <div class="dialogue-label">Ahmed:</div>
                <p>"Linear probing is simple but suffers from primary clustering. Quadratic probing reduces clustering, but may fail to visit all table positions."</p>
            </div>

            <div class="dialogue dialogue-omar">
                <div class="dialogue-label">Omar:</div>
                <p>"Double hashing is more flexible. Using two hash functions, and choosing the table size to be prime, we can ensure that we visit all positions and reduce clustering."</p>
            </div>

            <div class="key-concept">
                <h4>üéØ Final Conclusion</h4>
                <p><strong>If you want a robust and efficient hash table, double hashing with a prime-sized table is a powerful choice!</strong></p>
            </div>
        </section>

        <!-- Conclusion -->
        <section id="conclusion">
            <h2>Conclusion ‚Äî What We Learned</h2>

            <p>This tutorial has shown, step by step, how Ahmed and Omar move from simple arrays to sophisticated hash tables.</p>

            <h3>Key Takeaways</h3>

            <div class="summary-cards">
                <div class="summary-card">
                    <h4>1. Linear Search</h4>
                    <p>O(n) search can be too slow for large datasets.</p>
                </div>
                <div class="summary-card">
                    <h4>2. Binary Search</h4>
                    <p>O(log n) search but O(n) insertion to keep sorted.</p>
                </div>
                <div class="summary-card">
                    <h4>3. Direct Addressing</h4>
                    <p>O(1) search but wastes memory for sparse keys.</p>
                </div>
                <div class="summary-card">
                    <h4>4. Hash Tables</h4>
                    <p>Use modulo arithmetic to map keys to indices efficiently.</p>
                </div>
            </div>

            <h3>Collision Resolution Summary</h3>

            <table class="step-table">
                <tr>
                    <th>Method</th>
                    <th>Best For</th>
                    <th>Key Formula</th>
                </tr>
                <tr>
                    <td><strong>Linear Probing</strong></td>
                    <td>Simple implementations, good cache locality</td>
                    <td>(h(k) + i) mod m</td>
                </tr>
                <tr>
                    <td><strong>Quadratic Probing</strong></td>
                    <td>Reducing primary clustering, table < 50% full</td>
                    <td>(h(k) + i¬≤) mod m</td>
                </tr>
                <tr>
                    <td><strong>Double Hashing</strong></td>
                    <td>Best distribution, minimal clustering</td>
                    <td>(h‚ÇÅ(k) + i √ó h‚ÇÇ(k)) mod m</td>
                </tr>
            </table>

            <div class="info-box tip">
                <div class="info-box-title">üìö Practice Exercises</div>
                <ul>
                    <li>Try inserting different keys by hand using each probing method</li>
                    <li>Compare the number of probes needed for each method</li>
                    <li>Implement these methods in your favorite programming language</li>
                    <li>Experiment with different table sizes and load factors</li>
                </ul>
            </div>
        </section>
    </main>

    <footer>
        <p><strong>From Arrays to Hash Tables</strong></p>
        <p>A Story of Ahmed and Omar Discovering Hashing</p>
        <p style="margin-top: 1rem; font-size: 1.1rem;"><strong>Prepared by Dr. Almalawi</strong></p>
        <p>CPCS 204 - Data Structures</p>
    </footer>
</body>
</html>
